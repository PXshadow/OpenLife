<!-- This file can be parsed by haxe.rtti.XmlParser -->
<haxe>
	<class path="neko.Lib" params="" file="/usr/local/lib/haxe/std/neko/Lib.hx">
		<load public="1" set="method" line="34" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Load and return a Neko primitive from a NDLL library.</haxe_doc>
		</load>
		<loadLazy public="1" set="method" line="38" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</loadLazy>
		<rethrow public="1" set="method" line="66" static="1">
			<f a="e">
				<d/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Rethrow an exception. This is useful when manually filtering an exception in order
		to keep the previous exception stack.</haxe_doc>
		</rethrow>
		<haxe_doc>Platform-specific Neko Library. Provides some platform-specific functions
	for the Neko target, such as conversion from Haxe types to native types
	and vice-versa.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="Array" params="T" file="/usr/local/lib/haxe/std/neko/_std/Array.hx">
		<new1 params="T" set="method" line="32" static="1"><f a="a:l">
	<c path="neko.NativeArray"><c path="new1.T"/></c>
	<x path="Int"/>
	<c path="Array"><c path="new1.T"/></c>
</f></new1>
		<__hx_toString_depth expr="0" line="96" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__hx_toString_depth>
		<__a><c path="neko.NativeArray"><c path="Array.T"/></c></__a>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method" line="39">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<copy public="1" set="method" line="50">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<iterator public="1" set="method" line="54">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<insert public="1" set="method" line="69">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.

		This operation modifies `this` Array in place.

		The offset is calculated like so:

		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this`
		  Array, i.e. `this.length + pos`. If this yields a negative value, the
		  offset is 0.
		- Otherwise, the offset is `pos`.

		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<join public="1" set="method" line="84">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<toString public="1" set="method" line="98">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.

		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use `Std.string()` to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<pop public="1" set="method" line="121">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method" line="130">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<unshift public="1" set="method" line="137">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<remove public="1" set="method" line="145">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurrence of `x` in `this` Array.

		This operation modifies `this` Array in place.

		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed accordingly. The function
		then returns true.

		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<indexOf public="1" set="method" line="162">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurrence of `x` in `this` Array, searching front to back.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with zero index. If it is negative, it will be taken as the
		offset from the end of `this` Array to compute the starting index. If given or computed
		starting index is less than 0, the whole array will be searched, if it is greater than
		or equal to the length of `this` Array, the function returns -1.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method" line="179">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the last occurrence of `x` in `this` Array, searching back to front.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with the last element index. If it is negative, it will be
		taken as the offset from the end of `this` Array to compute the starting index. If
		given or computed starting index is greater than or equal to the length of `this` Array,
		the whole array will be searched, if it is less than 0, the function returns -1.</haxe_doc>
		</lastIndexOf>
		<reverse public="1" set="method" line="195">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.

		This operation modifies `this` Array in place.

		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method" line="209">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method" line="222">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` is less than or equals
		`pos`, the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method" line="240">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.ArraySort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method" line="263">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, an empty Array [] is
		returned and `this` Array is unchanged.

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<map public="1" params="S" get="inline" set="null" line="289">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<filter public="1" get="inline" set="null" line="298">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.

		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<resize public="1" set="method" line="306">
			<f a="len">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the length of the Array.

		If `len` is shorter than the array's current size, the last
		`length - len` elements will be removed. If `len` is longer, the Array
		will be extended, with new elements set to a target-specific default
		value:

		- always null on dynamic targets
		- 0, 0.0 or false for Int, Float and Bool respectively on static targets
		- null for other types on static targets</haxe_doc>
		</resize>
		<__get set="method" line="318"><f a="pos">
	<x path="Int"/>
	<c path="Array.T"/>
</f></__get>
		<__set set="method" line="322"><f a="pos:v">
	<x path="Int"/>
	<c path="Array.T"/>
	<c path="Array.T"/>
</f></__set>
		<__grow set="method" line="343"><f a="l">
	<x path="Int"/>
	<x path="Void"/>
</f></__grow>
		<__neko set="method" line="359"><f a=""><c path="neko.NativeArray"><c path="Array.T"/></c></f></__neko>
		<new public="1" set="method" line="27">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API.

	@see https://haxe.org/manual/std-Array.html
	@see https://haxe.org/manual/lf-array-comprehension.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Class" params="T" file="/usr/local/lib/haxe/std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-class-instance.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="/usr/local/lib/haxe/std/neko/_std/Date.hx">
		<date_format expr="Lib.load(&quot;std&quot;, &quot;date_format&quot;, 2)" line="125" static="1">
			<f a=":">
				<d/>
				<unknown/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>Lib.load("std", "date_format", 2)</e></m></meta>
		</date_format>
		<date_set_hour expr="Lib.load(&quot;std&quot;, &quot;date_set_hour&quot;, 4)" line="127" static="1">
			<f a=":::">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>Lib.load("std", "date_set_hour", 4)</e></m></meta>
		</date_set_hour>
		<date_set_day expr="Lib.load(&quot;std&quot;, &quot;date_set_day&quot;, 4)" line="128" static="1">
			<f a=":::">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>Lib.load("std", "date_set_day", 4)</e></m></meta>
		</date_set_day>
		<__string set="method" line="138" static="1">
			<f a=""><c path="String"/></f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
		</__string>
		<__t><d/></__t>
		<toString public="1" set="method" line="97">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Returns a string representation of `this` Date in the local timezone
		using the standard format `YYYY-MM-DD HH:MM:SS`. See `DateTools.format` for
		other formatting rules.</haxe_doc>
		</toString>
		<new public="1" set="method" line="28">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.

		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.

		- month: 0 to 11 (note that this is zero-based)
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by

	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.

	There are some extra functions available in the `DateTools` class.

	In the context of Haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970 UTC.

	## Supported range

	Due to platform limitations, only dates in the range 1970 through 2038 are
	supported consistently. Some targets may support dates outside this range,
	depending on the OS at runtime. The `Date.fromTime` method will not work with
	timestamps outside the range on any target.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="EReg" params="" file="/usr/local/lib/haxe/std/neko/_std/EReg.hx">
		<regexp_new_options expr="neko.Lib.load(&quot;regexp&quot;, &quot;regexp_new_options&quot;, 2)" line="205" static="1">
			<f a=":">
				<unknown/>
				<unknown/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("regexp", "regexp_new_options", 2)</e></m></meta>
		</regexp_new_options>
		<regexp_match expr="neko.Lib.load(&quot;regexp&quot;, &quot;regexp_match&quot;, 4)" line="206" static="1">
			<f a=":::">
				<d/>
				<unknown/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("regexp", "regexp_match", 4)</e></m></meta>
		</regexp_match>
		<regexp_matched expr="neko.Lib.load(&quot;regexp&quot;, &quot;regexp_matched&quot;, 2)" line="207" static="1">
			<f a=":">
				<d/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("regexp", "regexp_matched", 2)</e></m></meta>
		</regexp_matched>
		<regexp_matched_pos expr="neko.Lib.load(&quot;regexp&quot;, &quot;regexp_matched_pos&quot;, 2)" line="208" static="1">
			<f a=":">
				<d/>
				<x path="Int"/>
				<a>
					<pos><x path="Int"/></pos>
					<len><x path="Int"/></len>
				</a>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("regexp", "regexp_matched_pos", 2)</e></m></meta>
		</regexp_matched_pos>
		<r><d/></r>
		<last><c path="String"/></last>
		<global><x path="Bool"/></global>
		<match public="1" set="method" line="35">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Tells if `this` regular expression matches String `s`.

		This method modifies the internal state.

		If `s` is `null`, the result is unspecified.</haxe_doc>
		</match>
		<matched public="1" set="method" line="44">
			<f a="n">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the matched sub-group `n` of `this` EReg.

		This method should only be called after `this.match` or
		`this.matchSub`, and then operates on the String of that operation.

		The index `n` corresponds to the n-th set of parentheses in the pattern
		of `this` EReg. If no such sub-group exists, the result is unspecified.

		If `n` equals 0, the whole matched substring is returned.</haxe_doc>
		</matched>
		<matchedPos public="1" set="method" line="60">
			<f a=""><a>
	<pos><x path="Int"/></pos>
	<len><x path="Int"/></len>
</a></f>
			<haxe_doc>Returns the position and length of the last matched substring, within
		the String which was last used as argument to `this.match` or
		`this.matchSub`.

		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.

		If the global g modifier was in place for the matching, the position and
		length of the leftmost substring is returned.</haxe_doc>
		</matchedPos>
		<new public="1" set="method" line="27">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.

		This is equivalent to the shorthand syntax `~/r/opt`

		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The EReg class represents regular expressions.

	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.

	EReg instances can be created by calling the constructor, or with the
	special syntax `~/pattern/modifier`

	EReg instances maintain an internal state, which is affected by several of
	its methods.

	A detailed explanation of the supported operations is available at
	<https://haxe.org/manual/std-regex.html>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Enum" params="T" file="/usr/local/lib/haxe/std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/usr/local/lib/haxe/std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
		<impl><class path="_EnumValue.EnumValue_Impl_" params="" file="/usr/local/lib/haxe/std/EnumValue.hx" private="1" module="EnumValue"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="IntIterator" params="" file="/usr/local/lib/haxe/std/IntIterator.hx">
		<min>
			<x path="Int"/>
			<meta><m n=":keep"/></meta>
		</min>
		<max>
			<x path="Int"/>
			<meta><m n=":keep"/></meta>
		</max>
		<hasNext public="1" get="inline" set="null" line="53">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Returns true if the iterator has other items, false otherwise.</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="62">
			<f a=""><x path="Int"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Moves to the next item of the iterator.

		If this is called while hasNext() is false, the result is unspecified.</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="45">
			<f a="min:max">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc><![CDATA[Iterates from `min` (inclusive) to `max` (exclusive).

		If `max <= min`, the iterator will not act as a countdown.]]></haxe_doc>
		</new>
		<haxe_doc>IntIterator is used for implementing interval iterations.

	It is usually not used explicitly, but through its special syntax:
	`min...max`

	While it is possible to assign an instance of IntIterator to a variable or
	field, it is worth noting that IntIterator does not reset after being used
	in a for-loop. Subsequent uses of the same instance will then have no
	effect.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="Lambda" params="" file="/usr/local/lib/haxe/std/Lambda.hx">
		<exists public="1" params="A" set="method" line="125" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="exists.A"/></t>
				<f a="item">
					<c path="exists.A"/>
					<x path="Bool"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `it` contains an element for which `f` is true.

		This function returns true as soon as an element is found for which a
		call to `f` returns true.

		If no such element is found, the result is false.

		If `f` is null, the result is unspecified.</haxe_doc>
		</exists>
		<haxe_doc>The `Lambda` class is a collection of methods to support functional
	programming. It is ideally used with `using Lambda` and then acts as an
	extension to Iterable types.

	On static platforms, working with the Iterable structure might be slower
	than performing the operations directly on known types, such as Array and
	List.

	If the first argument to any of the methods is null, the result is
	unspecified.

	@see https://haxe.org/manual/std-Lambda.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="Main" params="" file="src/Main.hx">
		<client public="1" static="1"><c path="client.Client"/></client>
		<settings public="1" static="1"><c path="settings.Settings"/></settings>
		<player public="1" static="1"><c path="game.Player"/></player>
		<range public="1" expr="16" line="78" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</range>
		<data public="1" static="1"><c path="data.GameData"/></data>
		<main public="1" set="method" line="94" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</main>
		<console><c path="console.Console"/></console>
		<selectX expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</selectX>
		<selectY expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</selectY>
		<playerInstance><c path="data.PlayerInstance"/></playerInstance>
		<mapInstance><c path="data.MapInstance"/></mapInstance>
		<index expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</index>
		<compress expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</compress>
		<inital expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</inital>
		<program><c path="console.Program"/></program>
		<string expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</string>
		<gameBool expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</gameBool>
		<lerpInt expr="2">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</lerpInt>
		<renderTime expr="null">
			<c path="haxe.Timer"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</renderTime>
		<foodPercent expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</foodPercent>
		<dir public="1" set="method" line="178"><f a=""><x path="Void"/></f></dir>
		<exist public="1" set="method" line="203"><f a="folders">
	<c path="Array"><c path="String"/></c>
	<x path="Bool"/>
</f></exist>
		<cred public="1" set="method" line="211"><f a=""><x path="Void"/></f></cred>
		<valid public="1" set="method" line="253"><f a="obj">
	<d/>
	<x path="Bool"/>
</f></valid>
		<end set="method" line="609"><f a=""><x path="Void"/></f></end>
		<connect set="method" line="640"><f a=""><x path="Void"/></f></connect>
		<analyze set="method" line="667"><f a=""><x path="Void"/></f></analyze>
		<message set="method" line="693"><f a="input">
	<c path="String"/>
	<x path="Void"/>
</f></message>
		<new public="1" set="method" line="99"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="Map" params="K:V" file="/usr/local/lib/haxe/std/Map.hx"><x path="haxe.ds.Map">
	<c path="Map.K"/>
	<c path="Map.V"/>
</x></typedef>
	<typedef path="IMap" params="K:V" file="/usr/local/lib/haxe/std/Map.hx" module="Map">
		<c path="haxe.IMap">
			<c path="IMap.K"/>
			<c path="IMap.V"/>
		</c>
		<meta>
			<m n=":dox"><e>hide</e></m>
			<m n=":deprecated"/>
		</meta>
	</typedef>
	<class path="_Math.MathImpl" params="" file="/usr/local/lib/haxe/std/neko/_std/Math.hx" private="1" module="Math">
		<__rnd static="1"><d/></__rnd>
		<_rand_float expr="Lib.load(&quot;std&quot;, &quot;random_float&quot;, 1)" line="29" static="1">
			<f a="">
				<d/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>Lib.load("std", "random_float", 1)</e></m></meta>
		</_rand_float>
		<_rand_int expr="Lib.load(&quot;std&quot;, &quot;random_int&quot;, 2)" line="30" static="1">
			<unknown/>
			<meta><m n=":value"><e>Lib.load("std", "random_int", 2)</e></m></meta>
		</_rand_int>
		<min public="1" set="method" line="32" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</min>
		<max public="1" set="method" line="36" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</max>
		<random public="1" set="method" line="40" static="1"><f a=""><x path="Float"/></f></random>
		<isNaN public="1" set="method" line="44" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</isNaN>
		<isFinite public="1" set="method" line="48" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</isFinite>
		<meta>
			<m n=":native"><e>"Math"</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="Math" params="" file="/usr/local/lib/haxe/std/neko/_std/Math.hx" extern="1">
		<PI public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>Represents the ratio of the circumference of a circle to its diameter,
		specified by the constant, Ï€. `PI` is approximately 3.141592653589793.</haxe_doc>
		</PI>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes an invalid number.

		NaN stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: Math.sqrt(-1).

		All further operations with `NaN` as an operand will result in `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.

		In order to test if a value is `NaN`, you should use `Math.isNaN()` function.</haxe_doc>
		</NaN>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes positive infinity.

		For example, this is the result of 1.0 / 0.0.

		Operations with `POSITIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes negative infinity.

		For example, this is the result of -1.0 / 0.0.

		Operations with `NEGATIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.

		If `a` or `b` are `NaN`, the result is `NaN`.
		If `a` or `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.
		If `a` and `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.

		If `a` or `b` are `NaN`, the result is `NaN`.
		If `a` or `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `a` and `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</max>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.

		If `v` is positive or 0, the result is unchanged. Otherwise the result
		is -`v`.

		If `v` is `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is
		`POSITIVE_INFINITY`.

		If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</abs>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</cos>
		<atan2 public="1" set="method" static="1">
			<f a="y:x">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent whose tangent is the quotient of
		two specified numbers, in radians.

		If parameter `x` or `y`  is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is `NaN`.</haxe_doc>
		</atan2>
		<tan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric tangent of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</tan>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of `v`.

		exp(1.0) is approximately 2.718281828459.

		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `NEGATIVE_INFINITY`, the result is `0.0`.
		If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of `v`.

		This is the mathematical inverse operation of exp,
		i.e. `log(exp(v)) == v` always holds.

		If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result
		is `NaN`.
		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `0.0`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</log>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.

		If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result
		is `NaN`.
		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `0.0`, the result is `0.0`.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value.

		Ties are rounded up, so that `0.5` becomes `1` and `-0.5` becomes `0`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</ceil>
		<atan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</atan>
		<asin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</asin>
		<acos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc cosine of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</acos>
		<pow public="1" set="method" static="1">
			<f a="v:exp">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns a specified base `v` raised to the specified power `exp`.</haxe_doc>
		</pow>
		<fround public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fround>
		<ffloor public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></ffloor>
		<fceil public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to 0.0,
		and less than 1.0.</haxe_doc>
		</random>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is not a valid number.

		If `f` is `NaN`, the result is `true`, otherwise the result is `false`.
		In particular, both `POSITIVE_INFINITY` and `NEGATIVE_INFINITY` are
		not considered `NaN`.</haxe_doc>
		</isNaN>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.

		If `f` is `POSITIVE_INFINITY`, `NEGATIVE_INFINITY` or `NaN`, the result
		is `false`, otherwise the result is `true`.</haxe_doc>
		</isFinite>
		<haxe_doc>This class defines mathematical functions and constants.

	@see https://haxe.org/manual/std-math.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Reflect" params="" file="/usr/local/lib/haxe/std/neko/_std/Reflect.hx">
		<callMethod public="1" set="method" line="58" static="1">
			<f a="o:func:args">
				<d/>
				<x path="haxe.Function"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Call a method `func` with the given arguments `args`.

		The object `o` is ignored in most cases. It serves as the `this`-context in the following
		situations:

		* (neko) Allows switching the context to `o` in all cases.
		* (macro) Same as neko for Haxe 3. No context switching in Haxe 4.
		* (js, lua) Require the `o` argument if `func` does not, but should have a context.
			This can occur by accessing a function field natively, e.g. through `Reflect.field`
			or by using `(object : Dynamic).field`. However, if `func` has a context, `o` is
			ignored like on other targets.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="71" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the fields of structure `o`.

		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<isObject public="1" set="method" line="107" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc><![CDATA[Tells if `v` is an object.

		The result is true if `v` is one of the following:

		- class instance
		- structure
		- `Class<T>`
		- `Enum<T>`

		Otherwise, including if `v` is null, the result is false.]]></haxe_doc>
		</isObject>
		<isEnumValue public="1" set="method" line="112" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Tells if `v` is an enum value.

		The result is true if `v` is of type EnumValue, i.e. an enum
		constructor.

		Otherwise, including if `v` is null, the result is false.</haxe_doc>
		</isEnumValue>
		<copy public="1" params="T" set="method" line="122" static="1">
			<f a="o">
				<x path="Null"><c path="copy.T"/></x>
				<x path="Null"><c path="copy.T"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Copies the fields of structure `o`.

		This is only guaranteed to work on anonymous structures.

		If `o` is null, the result is `null`.</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="129" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
			<overloads><makeVarArgs public="1" set="method"><f a="f">
	<f a="">
		<c path="Array"><d/></c>
		<x path="Void"/>
	</f>
	<d/>
</f></makeVarArgs></overloads>
		</makeVarArgs>
		<same_closure expr="try neko.Lib.load(&quot;std&quot;, &quot;same_closure&quot;, 2) catch(e:Dynamic) function(f1, f2) return f1 == f2" line="135" static="1">
			<f a="f1:f2">
				<unknown/>
				<unknown/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>try neko.Lib.load("std", "same_closure", 2) catch(e:Dynamic) function(f1, f2) return f1 == f2</e></m></meta>
		</same_closure>
		<haxe_doc>The Reflect API is a way to manipulate values dynamically through an
	abstract interface in an untyped manner. Use with care.

	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Static" params="" file="src/Static.hx">
		<dir public="1" expr="&quot;&quot;" line="11" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</dir>
		<GRID public="1" get="inline" set="null" expr="128" line="13" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>128</e></m></meta>
		</GRID>
		<tileHeight public="1" get="inline" set="null" expr="30" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>30</e></m></meta>
		</tileHeight>
		<babyHeadDownFactor public="1" get="inline" set="null" expr="0.6" line="16" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.6</e></m></meta>
		</babyHeadDownFactor>
		<babyBodyDownFactor public="1" get="inline" set="null" expr="0.75" line="17" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.75</e></m></meta>
		</babyBodyDownFactor>
		<oldHeadDownFactor public="1" get="inline" set="null" expr="0.35" line="18" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.35</e></m></meta>
		</oldHeadDownFactor>
		<oldHeadForwardFactor public="1" get="inline" set="null" expr="2" line="19" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</oldHeadForwardFactor>
		<request public="1" set="method" line="21" static="1"><f a="url:complete">
	<c path="String"/>
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></request>
		<execute public="1" set="method" line="31" static="1"><f a="url">
	<c path="String"/>
	<x path="Void"/>
</f></execute>
		<arrayEqual public="1" set="method" line="41" static="1"><f a="a:b">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<x path="Bool"/>
</f></arrayEqual>
		<number public="1" set="method" line="50" static="1"><f a=""><x path="Int"/></f></number>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="Int" params="" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard `Int` type. Its precision depends on the platform.

	On static targets, `null` cannot be assigned to `Int`. If this is necessary,
	`Null<Int>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseInt` converts a `String` to an `Int`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/std-math-integer-math.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Float" params="" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard `Float` type, this is a double-precision IEEE 64bit float.

	On static targets, `null` cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseFloat` converts a `String` to a `Float`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Bool" params="" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be `true` or `false`.

	On static targets, `null` cannot be assigned to `Bool`. If this is necessary,
	`Null<Bool>` can be used instead.

	@see https://haxe.org/manual/types-bool.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>`Dynamic` is a special type which is compatible with all other types.

	Use of `Dynamic` should be minimized as it prevents several compiler
	checks and optimizations. See `Any` type for a safer alternative for
	representing values of any type.

	@see https://haxe.org/manual/types-dynamic.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="neko.Boot" params="" file="/usr/local/lib/haxe/std/neko/Boot.hx">
		<__tmp_str set="method" line="28" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":has_untyped"/></meta>
		</__tmp_str>
		<__enum_str set="method" line="32" static="1">
			<f a="e">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__enum_str>
		<__interfLoop set="method" line="54" static="1"><f a="cc:cl">
	<d/>
	<d/>
	<x path="Bool"/>
</f></__interfLoop>
		<__instanceof set="method" line="70" static="1">
			<f a="o:cl">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":ifFeature"><e>"typed_catch"</e></m>
			</meta>
		</__instanceof>
		<__serialize set="method" line="91" static="1">
			<f a="o">
				<a>
					<__enum__ set="null"><a><__ename__ set="null"><a><length set="null"><x path="Int"/></length></a></__ename__></a></__enum__>
					<__class__ set="null"><a><__name__ set="null"><a><length set="null"><x path="Int"/></length></a></__name__></a></__class__>
				</a>
				<c path="Array"><unknown/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__serialize>
		<__tagserialize set="method" line="111" static="1">
			<f a="o">
				<d/>
				<c path="Array"><unknown/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__tagserialize>
		<__unserialize set="method" line="121" static="1">
			<f a="v">
				<d/>
				<unknown/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__unserialize>
		<__init set="method" line="144" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</__init>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="Std" params="" file="/usr/local/lib/haxe/std/neko/_std/Std.hx">
		<is public="1" set="method" line="24" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":ifFeature"><e>"typed_cast"</e></m>
			</meta>
			<haxe_doc>Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.

		If `t` is a class or interface with `@:generic` meta, the result is `false`.</haxe_doc>
		</is>
		<string public="1" set="method" line="37" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" set="method" line="41" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts a `Float` to an `Int`, rounded towards 0.

		If `x` is outside of the signed Int32 range, or is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="47" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		If `x` starts with 0x or 0X, hexadecimal notation is recognized where the following digits may
		contain 0-9 and A-F.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. `x` may also start with
		a - to denote a negative value.

		In decimal mode, parsing continues until an invalid character is detected, in which case the
		result up to that point is returned. For hexadecimal notation, the effect of invalid characters
		is unspecified.

		Leading 0s that are not part of the 0x/0X hexadecimal notation are ignored, which means octal
		notation is not supported.

		If `x` is null, the result is unspecified.
		If `x` cannot be parsed as integer, the result is `null`.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="59" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a `NaN` value instead of null.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="69" static="1">
			<f a="x">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc><![CDATA[Return a random integer between 0 included and `x` excluded.

		If `x <= 1`, the result is always 0.]]></haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard `Void` type. Only `null` values can be of the type `Void`.

	@see https://haxe.org/manual/types-void.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Null" params="T" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<from><icast><c path="Null.T"/></icast></from>
		<this><x path="Null"><c path="Null.T"/></x></this>
		<to><icast><c path="Null.T"/></icast></to>
		<haxe_doc><![CDATA[`Null<T>` is a wrapper that can be used to make the basic types `Int`,
	`Float` and `Bool` nullable on static targets.

	If null safety is enabled, only types wrapped in `Null<T>` are nullable.

	Otherwise, it has no effect on non-basic-types, but it can be useful as a way to document
	that `null` is an acceptable value for a method argument, return value or variable.

	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An `Iterator` is a structure that permits iteration over elements of type `T`.

	Any class with matching `hasNext()` and `next()` fields is considered an `Iterator`
	and can then be used e.g. in `for`-loops. This makes it easy to implement
	custom iterators.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An `Iterable` is a data structure which has an `iterator()` method.
	See `Lambda` for generic functions on iterable structures.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterator" params="K:V" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<t path="Iterator"><a>
	<value><c path="KeyValueIterator.V"/></value>
	<key><c path="KeyValueIterator.K"/></key>
</a></t>
		<haxe_doc>A `KeyValueIterator` is an `Iterator` that has a key and a value.</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterable" params="K:V" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><keyValueIterator set="method"><f a=""><t path="KeyValueIterator">
	<c path="KeyValueIterable.K"/>
	<c path="KeyValueIterable.V"/>
</t></f></keyValueIterator></a>
		<haxe_doc>A `KeyValueIterable` is a data structure which has a `keyValueIterator()`
	method to iterate over key-value-pairs.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>`ArrayAccess` is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.

	This interface should be used for externs only. Haxe does not support custom
	array access on classes. However, array access can be implemented for
	abstract types.

	@see https://haxe.org/manual/types-abstract-array-access.html</haxe_doc></class>
	<class path="String" params="" file="/usr/local/lib/haxe/std/neko/_std/String.hx">
		<__is_String expr="true" line="23" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</__is_String>
		<__split expr="neko.Lib.load(&quot;std&quot;, &quot;string_split&quot;, 2)" line="24" static="1">
			<d/>
			<meta><m n=":value"><e>neko.Lib.load("std", "string_split", 2)</e></m></meta>
		</__split>
		<fromCharCode public="1" set="method" line="212" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<charAt public="1" set="method" line="41">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String `""`
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method" line="53">
			<f a="index">
				<x path="Int"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, `null` is returned.

		To obtain the character code of a single character, `"x".code` can be
		used instead to inline the character code at compile time. Note that
		this only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method" line="59">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the position of the leftmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex` (if `startIndex` is posivite
		or 0) or `max(this.length + startIndex, 0)` (if `startIndex` is negative).

		If `startIndex` exceeds `this.length`, -1 is returned.

		Otherwise the search is performed within `this` String. In either case,
		the returned position is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method" line="75">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the position of the rightmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex + str.length`. Otherwise the search
		is performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method" line="92">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Splits `this` String at each occurrence of `delimiter`.

		If `this` String is the empty String `""`, the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String `""`, `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurrence of
		`delimiter`. If `this` String starts (or ends) with `delimiter`, the
		result `Array` contains a leading (or trailing) empty String `""` element.
		Two subsequent delimiters also result in an empty String `""` element.</haxe_doc>
		</split>
		<substr public="1" set="method" line="108">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<substring public="1" set="method" line="139">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String `""` is returned.</haxe_doc>
		</substring>
		<toLowerCase public="1" set="method" line="163">
			<f a=""><c path="String"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.</haxe_doc>
		</toLowerCase>
		<toUpperCase public="1" set="method" line="179">
			<f a=""><c path="String"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.</haxe_doc>
		</toUpperCase>
		<toString public="1" set="method" line="195">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<__compare set="method" line="200">
			<f a="o">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__compare>
		<__add set="method" line="204">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__add>
		<__radd set="method" line="208">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__radd>
		<new public="1" set="method" line="32">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A Haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the String literal syntax `"string value"`.

	String can be concatenated by using the `+` operator. If an operand is not a
	String, it is passed through `Std.string()` first.

	@see https://haxe.org/manual/std-String.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="StringBuf" params="" file="/usr/local/lib/haxe/std/neko/_std/StringBuf.hx">
		<__make expr="neko.Lib.load(&quot;std&quot;, &quot;buffer_new&quot;, 0)" line="52" static="1">
			<d/>
			<meta><m n=":value"><e>neko.Lib.load("std", "buffer_new", 0)</e></m></meta>
		</__make>
		<__add expr="neko.Lib.load(&quot;std&quot;, &quot;buffer_add&quot;, 2)" line="53" static="1">
			<d/>
			<meta><m n=":value"><e>neko.Lib.load("std", "buffer_add", 2)</e></m></meta>
		</__add>
		<__add_char expr="neko.Lib.load(&quot;std&quot;, &quot;buffer_add_char&quot;, 2)" line="54" static="1">
			<d/>
			<meta><m n=":value"><e>neko.Lib.load("std", "buffer_add_char", 2)</e></m></meta>
		</__add_char>
		<__add_sub expr="neko.Lib.load(&quot;std&quot;, &quot;buffer_add_sub&quot;, 4)" line="55" static="1">
			<d/>
			<meta><m n=":value"><e>neko.Lib.load("std", "buffer_add_sub", 4)</e></m></meta>
		</__add_sub>
		<__to_string expr="neko.Lib.load(&quot;std&quot;, &quot;buffer_string&quot;, 1)" line="56" static="1">
			<d/>
			<meta><m n=":value"><e>neko.Lib.load("std", "buffer_string", 1)</e></m></meta>
		</__to_string>
		<__get_length expr="try neko.Lib.load(&quot;std&quot;, &quot;buffer_get_length&quot;, 1) catch(e:Dynamic) null" line="57" static="1">
			<d/>
			<meta><m n=":value"><e>try neko.Lib.load("std", "buffer_get_length", 1) catch(e:Dynamic) null</e></m></meta>
		</__get_length>
		<b><d/></b>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` StringBuf in characters.</haxe_doc>
		</length>
		<get_length set="method" line="31">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
		</get_length>
		<new public="1" set="method" line="27">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.

		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.

	Its cross-platform implementation uses String concatenation internally, but
	StringBuf may be optimized for different targets.

	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values. However, the internal buffer cannot be modified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.SysTools" params="" file="/usr/local/lib/haxe/std/haxe/SysTools.hx">
		<winMetaCharacters final="1" public="1" set="null" expr="[&quot; &quot;.code, &quot;(&quot;.code, &quot;)&quot;.code, &quot;%&quot;.code, &quot;!&quot;.code, &quot;^&quot;.code, &quot;\&quot;&quot;.code, &quot;&lt;&quot;.code, &quot;&gt;&quot;.code, &quot;&amp;&quot;.code, &quot;|&quot;.code, &quot;\n&quot;.code, &quot;\r&quot;.code, &quot;,&quot;.code, &quot;;&quot;.code]" line="9" static="1">
			<x path="haxe.ds.ReadOnlyArray"><x path="Int"/></x>
			<meta><m n=":value"><e><![CDATA[[" ".code, "(".code, ")".code, "%".code, "!".code, "^".code, "\"".code, "<".code, ">".code, "&".code, "|".code, "\n".code, "\r".code, ",".code, ";".code]]]></e></m></meta>
			<haxe_doc>Character codes of the characters that will be escaped by `quoteWinArg(_, true)`.</haxe_doc>
		</winMetaCharacters>
		<quoteUnixArg public="1" set="method" line="18" static="1">
			<f a="argument">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a String that can be used as a single command line argument
		on Unix.
		The input will be quoted, or escaped if necessary.</haxe_doc>
		</quoteUnixArg>
		<quoteWinArg public="1" set="method" line="46" static="1">
			<f a="argument:escapeMetaCharacters">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a String that can be used as a single command line argument
		on Windows.
		The input will be quoted, or escaped if necessary, such that the output
		will be parsed as a single argument using the rule specified in
		http://msdn.microsoft.com/en-us/library/ms880421

		Examples:
		```haxe
		quoteWinArg("abc") == "abc";
		quoteWinArg("ab c") == '"ab c"';
		```</haxe_doc>
		</quoteWinArg>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="StringTools" params="" file="/usr/local/lib/haxe/std/StringTools.hx">
		<startsWith public="1" set="method" line="222" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` starts with the string `start`.

		If `start` is `null`, the result is unspecified.

		If `start` is the empty String `""`, the result is true.</haxe_doc>
		</startsWith>
		<isSpace public="1" set="method" line="288" static="1">
			<f a="s:pos">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string `s` at position `pos` is a space.

		A character is considered to be a space character if its character code
		is 9,10,11,12,13 or 32.

		If `s` is the empty String `""`, or if pos is not a valid position within
		`s`, the result is false.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="306" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading space characters of `s`.

		This function internally calls `isSpace()` to decide which characters to
		remove.

		If `s` is the empty String `""` or consists only of space characters, the
		result is the empty String `""`.</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="331" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes trailing space characters of `s`.

		This function internally calls `isSpace()` to decide which characters to
		remove.

		If `s` is the empty String `""` or consists only of space characters, the
		result is the empty String `""`.</haxe_doc>
		</rtrim>
		<replace public="1" set="method" line="422" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurrences of the String `sub` in the String `s` by the
		String `by`.

		If `sub` is the empty String `""`, `by` is inserted after each character
		of `s` except the last one. If `by` is also the empty String `""`, `s`
		remains unchanged.

		If `sub` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<_urlEncode expr="neko.Lib.load(&quot;std&quot;, &quot;url_encode&quot;, 1)" line="596" static="1">
			<f a="">
				<unknown/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "url_encode", 1)</e></m></meta>
		</_urlEncode>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)
	to the `String` class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="sys.FileSystem" params="" file="/usr/local/lib/haxe/std/neko/_std/sys/FileSystem.hx">
		<exists public="1" set="method" line="33" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns `true` if the file or directory specified by `path` exists.</haxe_doc>
		</exists>
		<kind set="method" line="59" static="1">
			<f a="path">
				<c path="String"/>
				<e path="sys._FileSystem.FileKind"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</kind>
		<readDirectory public="1" set="method" line="94" static="1">
			<f a="path">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the names of all files and directories in the directory specified
		by `path`. `"."` and `".."` are not included in the output.

		If `path` does not denote a valid directory, an exception is thrown.</haxe_doc>
		</readDirectory>
		<sys_exists expr="neko.Lib.load(&quot;std&quot;, &quot;sys_exists&quot;, 1)" line="114" static="1">
			<f a="">
				<unknown/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "sys_exists", 1)</e></m></meta>
		</sys_exists>
		<sys_file_type expr="neko.Lib.load(&quot;std&quot;, &quot;sys_file_type&quot;, 1)" line="118" static="1">
			<f a="">
				<unknown/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "sys_file_type", 1)</e></m></meta>
		</sys_file_type>
		<sys_read_dir expr="neko.Lib.load(&quot;std&quot;, &quot;sys_read_dir&quot;, 1)" line="121" static="1">
			<f a="">
				<unknown/>
				<c path="Array"><d/></c>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "sys_read_dir", 1)</e></m></meta>
		</sys_read_dir>
		<haxe_doc>This class provides information about files and directories.

	If `null` is passed as a file path to any function in this class, the
	result is unspecified, and may differ from target to target.

	See `sys.io.File` for the complementary file API.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Sys" params="" file="/usr/local/lib/haxe/std/neko/_std/Sys.hx">
		<println public="1" set="method" line="30" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Prints any value to the standard output, followed by a newline.
		On Windows, this function outputs a CRLF newline.
		LF newlines are printed on all other platforms.</haxe_doc>
		</println>
		<stdin public="1" set="method" line="38" static="1">
			<f a=""><c path="haxe.io.Input"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the standard input of the process, from which user input can be read.
		Usually it will block until the user sends a full input line.
		See `getChar` for an alternative.</haxe_doc>
		</stdin>
		<sleep public="1" set="method" line="76" static="1">
			<f a="seconds">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Suspends execution for the given length of time (in seconds).</haxe_doc>
		</sleep>
		<systemName public="1" set="method" line="92" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the type of the current system. Possible values are:
		 - `"Windows"`
		 - `"Linux"`
		 - `"BSD"`
		 - `"Mac"`</haxe_doc>
		</systemName>
		<command public="1" set="method" line="96" static="1">
			<f a="cmd:?args">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Runs the given command. The command output will be printed to the same output as the current process.
		The current process will block until the command terminates.
		The return value is the exit code of the command (usually `0` indicates no error).

		Command arguments can be passed in two ways:

		 1. Using `args` to pass command arguments. Each argument will be automatically quoted and shell meta-characters will be escaped if needed.
		`cmd` should be an executable name that can be located in the `PATH` environment variable, or a full path to an executable.

		 2. When `args` is not given or is `null`, command arguments can be appended to `cmd`. No automatic quoting/escaping will be performed. `cmd` should be formatted exactly as it would be when typed at the command line.
		It can run executables, as well as shell commands that are not executables (e.g. on Windows: `dir`, `cd`, `echo` etc).

		Use the `sys.io.Process` API for more complex tasks, such as background processes, or providing input to the command.</haxe_doc>
		</command>
		<exit public="1" set="method" line="114" static="1">
			<f a="code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Exits the current process with the given exit code.

		(macro)(eval) Being invoked in a macro or eval context (e.g. with `-x` or `--run`) immediately terminates
		the compilation process, which also prevents the execution of any `--next` sections of compilation arguments.</haxe_doc>
		</exit>
		<time public="1" set="method" line="118" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value available (in seconds).</haxe_doc>
		</time>
		<_sleep expr="neko.Lib.load(&quot;std&quot;, &quot;sys_sleep&quot;, 1)" line="152" static="1">
			<f a="">
				<x path="Float"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "sys_sleep", 1)</e></m></meta>
		</_sleep>
		<sys_string expr="neko.Lib.load(&quot;std&quot;, &quot;sys_string&quot;, 0)" line="156" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":value"><e>neko.Lib.load("std", "sys_string", 0)</e></m></meta>
		</sys_string>
		<sys_command expr="neko.Lib.load(&quot;std&quot;, &quot;sys_command&quot;, 1)" line="157" static="1">
			<f a="">
				<unknown/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "sys_command", 1)</e></m></meta>
		</sys_command>
		<sys_exit expr="neko.Lib.load(&quot;std&quot;, &quot;sys_exit&quot;, 1)" line="158" static="1">
			<f a="">
				<x path="Int"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "sys_exit", 1)</e></m></meta>
		</sys_exit>
		<sys_time expr="neko.Lib.load(&quot;std&quot;, &quot;sys_time&quot;, 0)" line="159" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":value"><e>neko.Lib.load("std", "sys_time", 0)</e></m></meta>
		</sys_time>
		<file_stdin expr="neko.Lib.load(&quot;std&quot;, &quot;file_stdin&quot;, 0)" line="195" static="1">
			<f a=""><e path="sys.io.FileHandle"/></f>
			<meta><m n=":value"><e>neko.Lib.load("std", "file_stdin", 0)</e></m></meta>
		</file_stdin>
		<haxe_doc>This class provides access to various base functions of system platforms.
	Look in the `sys` package for more system APIs.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Type" params="" file="/usr/local/lib/haxe/std/neko/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="37" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the class of `o`, if `o` is a class instance.

		If `o` is null or of a different type, null is returned.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<resolveClass public="1" set="method" line="70" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Resolves a class by name.

		If `name` is the path of an existing class, that class is returned.

		Otherwise null is returned.

		If `name` is null or the path to a different type, the result is
		unspecified.

		The class name must not include any type parameters.</haxe_doc>
		</resolveClass>
		<createInstance public="1" params="T" set="method" line="99" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates an instance of class `cl`, using `args` as arguments to the
		class constructor.

		This function guarantees that the class constructor is called.

		Default values of constructors arguments are not guaranteed to be
		taken into account.

		If `cl` or `args` are null, or if the number of elements in `args` does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if `cl` has no own constructor, the
		result is unspecified.

		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="112" static="1">
			<f a="cl">
				<x path="Class"><c path="createEmptyInstance.T"/></x>
				<c path="createEmptyInstance.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates an instance of class `cl`.

		This function guarantees that the class constructor is not called.

		If `cl` is null, the result is unspecified.</haxe_doc>
		</createEmptyInstance>
		<getInstanceFields public="1" set="method" line="136" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a list of the instance fields of class `c`, including
		inherited fields.

		This only includes fields which are known at compile-time. In
		particular, using `getInstanceFields(getClass(obj))` will not include
		any fields which were added to `obj` at runtime.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.

		(As3) This method only returns instance fields that are public.</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="153" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of static fields of class `c`.

		This does not include static fields of parent classes.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.

		(As3) This method only returns class fields that are public.</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="169" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getEnumConstructs>
		<enumEq public="1" params="T" set="method" line="196" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.

		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" line="211" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="215" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is [].

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumParameters>
		<haxe_doc>The Haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.

	@see https://haxe.org/manual/types.html
	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="UnitTest" params="" file="src/UnitTest.hx">
		<time expr="0" line="5" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</time>
		<time2 expr="0" line="6" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</time2>
		<inital public="1" set="method" line="7" static="1"><f a=""><x path="Void"/></f></inital>
		<stamp public="1" set="method" line="11" static="1"><f a=""><x path="Float"/></f></stamp>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="client.Client" params="" file="src/client/Client.hx">
		<socket><c path="sys.net.Socket"/></socket>
		<tag public="1"><x path="client.ClientTag"/></tag>
		<login public="1"><c path="client.Login"/></login>
		<data expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</data>
		<dataCompress><c path="haxe.io.Bytes"/></dataCompress>
		<aliveTimer><c path="haxe.Timer"/></aliveTimer>
		<connected expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</connected>
		<compress public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</compress>
		<tagRemove expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</tagRemove>
		<index expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</index>
		<message public="1"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></message>
		<end public="1"><f a=""><x path="Void"/></f></end>
		<ip public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</ip>
		<port public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</port>
		<reconnect public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</reconnect>
		<ping public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ping>
		<pingInt expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</pingInt>
		<update public="1" set="method" line="42"><f a=""><x path="Void"/></f></update>
		<process set="method" line="74"><f a=""><x path="Void"/></f></process>
		<alive public="1" set="method" line="105"><f a=""><x path="Void"/></f></alive>
		<send public="1" set="method" line="111"><f a="data">
	<c path="String"/>
	<x path="Void"/>
</f></send>
		<connect public="1" set="method" line="129"><f a=""><x path="Void"/></f></connect>
		<close public="1" set="method" line="157"><f a=""><x path="Void"/></f></close>
		<processCompress set="method" line="170"><f a=""><x path="Void"/></f></processCompress>
		<new public="1" set="method" line="38"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Socket Client</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="client.ClientTag" params="" file="src/client/ClientTag.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><x path="Null"><c path="String"/></x></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="client._ClientTag.ClientTag_Impl_" params="" file="src/client/ClientTag.hx" private="1" module="client.ClientTag">
	<COMPRESSED_MESSAGE public="1" get="inline" set="null" expr="cast &quot;CM&quot;" line="5" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "CM"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COMPRESSED_MESSAGE>
	<MAP_CHUNK public="1" get="inline" set="null" expr="cast &quot;MC&quot;" line="6" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "MC"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MAP_CHUNK>
	<PLAYER_UPDATE public="1" get="inline" set="null" expr="cast &quot;PU&quot;" line="7" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "PU"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PLAYER_UPDATE>
	<PLAYER_MOVES_START public="1" get="inline" set="null" expr="cast &quot;PM&quot;" line="8" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "PM"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PLAYER_MOVES_START>
	<PLAYER_OUT_OF_RANGE public="1" get="inline" set="null" expr="cast &quot;PO&quot;" line="9" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "PO"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PLAYER_OUT_OF_RANGE>
	<BABY_WIGGLE public="1" get="inline" set="null" expr="cast &quot;BW&quot;" line="10" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "BW"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BABY_WIGGLE>
	<PLAYER_SAYS public="1" get="inline" set="null" expr="cast &quot;PS&quot;" line="11" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "PS"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PLAYER_SAYS>
	<LOCATION_SAYS public="1" get="inline" set="null" expr="cast &quot;LS&quot;" line="12" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "LS"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LOCATION_SAYS>
	<PLAYER_EMOT public="1" get="inline" set="null" expr="cast &quot;PE&quot;" line="13" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "PE"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PLAYER_EMOT>
	<MAP_CHANGE public="1" get="inline" set="null" expr="cast &quot;MX&quot;" line="14" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "MX"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MAP_CHANGE>
	<FOOD_CHANGE public="1" get="inline" set="null" expr="cast &quot;FX&quot;" line="15" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "FX"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FOOD_CHANGE>
	<HEAT_CHANGE public="1" get="inline" set="null" expr="cast &quot;HX&quot;" line="16" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "HX"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEAT_CHANGE>
	<LINEAGE public="1" get="inline" set="null" expr="cast &quot;LN&quot;" line="17" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "LN"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LINEAGE>
	<NAME public="1" get="inline" set="null" expr="cast &quot;NM&quot;" line="18" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "NM"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NAME>
	<APOCALYPSE public="1" get="inline" set="null" expr="cast &quot;AP&quot;" line="19" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "AP"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APOCALYPSE>
	<APOCALYPSE_DONE public="1" get="inline" set="null" expr="cast &quot;AD&quot;" line="20" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "AD"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APOCALYPSE_DONE>
	<DYING public="1" get="inline" set="null" expr="cast &quot;DY&quot;" line="21" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "DY"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DYING>
	<HEALED public="1" get="inline" set="null" expr="cast &quot;HE&quot;" line="22" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "HE"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEALED>
	<MONUMENT_CALL public="1" get="inline" set="null" expr="cast &quot;MN&quot;" line="23" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "MN"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MONUMENT_CALL>
	<POSSE_JOIN public="1" get="inline" set="null" expr="cast &quot;PJ&quot;" line="24" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "PJ"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</POSSE_JOIN>
	<GRAVE public="1" get="inline" set="null" expr="cast &quot;GV&quot;" line="25" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "GV"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GRAVE>
	<GRAVE_MOVE public="1" get="inline" set="null" expr="cast &quot;GM&quot;" line="26" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "GM"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GRAVE_MOVE>
	<GRAVE_OLD public="1" get="inline" set="null" expr="cast &quot;GO&quot;" line="27" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "GO"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GRAVE_OLD>
	<OWNER_LIST public="1" get="inline" set="null" expr="cast &quot;OW&quot;" line="28" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "OW"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OWNER_LIST>
	<VALLEY_SPACING public="1" get="inline" set="null" expr="cast &quot;VS&quot;" line="29" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "VS"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VALLEY_SPACING>
	<CURSED public="1" get="inline" set="null" expr="cast &quot;CU&quot;" line="30" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "CU"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CURSED>
	<CURSE_TOKEN_CHANGE public="1" get="inline" set="null" expr="cast &quot;CX&quot;" line="31" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "CX"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CURSE_TOKEN_CHANGE>
	<CURSE_SCORE_CHANGE public="1" get="inline" set="null" expr="cast &quot;CS&quot;" line="32" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "CS"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CURSE_SCORE_CHANGE>
	<FLIGHT_DEST public="1" get="inline" set="null" expr="cast &quot;FD&quot;" line="33" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "FD"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FLIGHT_DEST>
	<VOG_UPDATE public="1" get="inline" set="null" expr="cast &quot;VU&quot;" line="34" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "VU"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VOG_UPDATE>
	<PHOTO_SIGNATURE public="1" get="inline" set="null" expr="cast &quot;PH&quot;" line="35" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "PH"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PHOTO_SIGNATURE>
	<FORCED_SHUTDOWN public="1" get="inline" set="null" expr="cast &quot;SD&quot;" line="36" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "SD"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FORCED_SHUTDOWN>
	<GLOBAL_MESSAGE public="1" get="inline" set="null" expr="cast &quot;MS&quot;" line="37" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "MS"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GLOBAL_MESSAGE>
	<WAR_REPORT public="1" get="inline" set="null" expr="cast &quot;WR&quot;" line="38" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "WR"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WAR_REPORT>
	<LEARNED_TOOL_REPORT public="1" get="inline" set="null" expr="cast &quot;LR&quot;" line="39" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "LR"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEARNED_TOOL_REPORT>
	<FRAME public="1" get="inline" set="null" expr="cast &quot;FM&quot;" line="40" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "FM"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FRAME>
	<PONG public="1" get="inline" set="null" expr="cast &quot;PONG&quot;" line="41" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "PONG"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PONG>
	<ACCEPTED public="1" get="inline" set="null" expr="cast &quot;ACCEPTED&quot;" line="43" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "ACCEPTED"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ACCEPTED>
	<REJECTED public="1" get="inline" set="null" expr="cast &quot;REJECTED&quot;" line="44" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "REJECTED"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</REJECTED>
	<SERVER_INFO public="1" get="inline" set="null" expr="cast &quot;SN&quot;" line="45" static="1">
		<x path="client.ClientTag"/>
		<meta>
			<m n=":value"><e>cast "SN"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SERVER_INFO>
	<fromString set="method" line="47" static="1">
		<f a="value">
			<c path="String"/>
			<x path="client.ClientTag"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="client._ClientTag.ClientTag_Impl_" params="" file="src/client/ClientTag.hx" private="1" module="client.ClientTag">
		<COMPRESSED_MESSAGE public="1" get="inline" set="null" expr="cast &quot;CM&quot;" line="5" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "CM"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COMPRESSED_MESSAGE>
		<MAP_CHUNK public="1" get="inline" set="null" expr="cast &quot;MC&quot;" line="6" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "MC"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MAP_CHUNK>
		<PLAYER_UPDATE public="1" get="inline" set="null" expr="cast &quot;PU&quot;" line="7" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "PU"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PLAYER_UPDATE>
		<PLAYER_MOVES_START public="1" get="inline" set="null" expr="cast &quot;PM&quot;" line="8" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "PM"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PLAYER_MOVES_START>
		<PLAYER_OUT_OF_RANGE public="1" get="inline" set="null" expr="cast &quot;PO&quot;" line="9" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "PO"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PLAYER_OUT_OF_RANGE>
		<BABY_WIGGLE public="1" get="inline" set="null" expr="cast &quot;BW&quot;" line="10" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "BW"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BABY_WIGGLE>
		<PLAYER_SAYS public="1" get="inline" set="null" expr="cast &quot;PS&quot;" line="11" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "PS"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PLAYER_SAYS>
		<LOCATION_SAYS public="1" get="inline" set="null" expr="cast &quot;LS&quot;" line="12" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "LS"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LOCATION_SAYS>
		<PLAYER_EMOT public="1" get="inline" set="null" expr="cast &quot;PE&quot;" line="13" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "PE"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PLAYER_EMOT>
		<MAP_CHANGE public="1" get="inline" set="null" expr="cast &quot;MX&quot;" line="14" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "MX"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MAP_CHANGE>
		<FOOD_CHANGE public="1" get="inline" set="null" expr="cast &quot;FX&quot;" line="15" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "FX"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FOOD_CHANGE>
		<HEAT_CHANGE public="1" get="inline" set="null" expr="cast &quot;HX&quot;" line="16" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "HX"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEAT_CHANGE>
		<LINEAGE public="1" get="inline" set="null" expr="cast &quot;LN&quot;" line="17" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "LN"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LINEAGE>
		<NAME public="1" get="inline" set="null" expr="cast &quot;NM&quot;" line="18" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "NM"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NAME>
		<APOCALYPSE public="1" get="inline" set="null" expr="cast &quot;AP&quot;" line="19" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "AP"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APOCALYPSE>
		<APOCALYPSE_DONE public="1" get="inline" set="null" expr="cast &quot;AD&quot;" line="20" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "AD"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APOCALYPSE_DONE>
		<DYING public="1" get="inline" set="null" expr="cast &quot;DY&quot;" line="21" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "DY"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DYING>
		<HEALED public="1" get="inline" set="null" expr="cast &quot;HE&quot;" line="22" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "HE"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEALED>
		<MONUMENT_CALL public="1" get="inline" set="null" expr="cast &quot;MN&quot;" line="23" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "MN"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MONUMENT_CALL>
		<POSSE_JOIN public="1" get="inline" set="null" expr="cast &quot;PJ&quot;" line="24" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "PJ"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</POSSE_JOIN>
		<GRAVE public="1" get="inline" set="null" expr="cast &quot;GV&quot;" line="25" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "GV"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GRAVE>
		<GRAVE_MOVE public="1" get="inline" set="null" expr="cast &quot;GM&quot;" line="26" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "GM"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GRAVE_MOVE>
		<GRAVE_OLD public="1" get="inline" set="null" expr="cast &quot;GO&quot;" line="27" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "GO"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GRAVE_OLD>
		<OWNER_LIST public="1" get="inline" set="null" expr="cast &quot;OW&quot;" line="28" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "OW"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OWNER_LIST>
		<VALLEY_SPACING public="1" get="inline" set="null" expr="cast &quot;VS&quot;" line="29" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "VS"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VALLEY_SPACING>
		<CURSED public="1" get="inline" set="null" expr="cast &quot;CU&quot;" line="30" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "CU"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CURSED>
		<CURSE_TOKEN_CHANGE public="1" get="inline" set="null" expr="cast &quot;CX&quot;" line="31" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "CX"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CURSE_TOKEN_CHANGE>
		<CURSE_SCORE_CHANGE public="1" get="inline" set="null" expr="cast &quot;CS&quot;" line="32" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "CS"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CURSE_SCORE_CHANGE>
		<FLIGHT_DEST public="1" get="inline" set="null" expr="cast &quot;FD&quot;" line="33" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "FD"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FLIGHT_DEST>
		<VOG_UPDATE public="1" get="inline" set="null" expr="cast &quot;VU&quot;" line="34" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "VU"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VOG_UPDATE>
		<PHOTO_SIGNATURE public="1" get="inline" set="null" expr="cast &quot;PH&quot;" line="35" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "PH"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PHOTO_SIGNATURE>
		<FORCED_SHUTDOWN public="1" get="inline" set="null" expr="cast &quot;SD&quot;" line="36" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "SD"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FORCED_SHUTDOWN>
		<GLOBAL_MESSAGE public="1" get="inline" set="null" expr="cast &quot;MS&quot;" line="37" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "MS"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GLOBAL_MESSAGE>
		<WAR_REPORT public="1" get="inline" set="null" expr="cast &quot;WR&quot;" line="38" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "WR"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WAR_REPORT>
		<LEARNED_TOOL_REPORT public="1" get="inline" set="null" expr="cast &quot;LR&quot;" line="39" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "LR"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEARNED_TOOL_REPORT>
		<FRAME public="1" get="inline" set="null" expr="cast &quot;FM&quot;" line="40" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "FM"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FRAME>
		<PONG public="1" get="inline" set="null" expr="cast &quot;PONG&quot;" line="41" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "PONG"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PONG>
		<ACCEPTED public="1" get="inline" set="null" expr="cast &quot;ACCEPTED&quot;" line="43" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "ACCEPTED"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ACCEPTED>
		<REJECTED public="1" get="inline" set="null" expr="cast &quot;REJECTED&quot;" line="44" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "REJECTED"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</REJECTED>
		<SERVER_INFO public="1" get="inline" set="null" expr="cast &quot;SN&quot;" line="45" static="1">
			<x path="client.ClientTag"/>
			<meta>
				<m n=":value"><e>cast "SN"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SERVER_INFO>
		<fromString set="method" line="47" static="1">
			<f a="value">
				<c path="String"/>
				<x path="client.ClientTag"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="client.Login" params="" file="src/client/Login.hx">
		<email public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</email>
		<challenge public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</challenge>
		<key public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</key>
		<twin public="1" expr="&quot;coding&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"coding"</e></m></meta>
		</twin>
		<tutorial public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</tutorial>
		<index expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</index>
		<version public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</version>
		<accept public="1"><f a=""><x path="Void"/></f></accept>
		<reject public="1"><f a=""><x path="Void"/></f></reject>
		<message public="1" set="method" line="22"><f a="data">
	<c path="String"/>
	<x path="Void"/>
</f></message>
		<request set="method" line="46"><f a=""><x path="Void"/></f></request>
		<new public="1" set="method" line="18"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="client.Router" params="" file="src/client/Router.hx">
		<socket public="1"><c path="sys.net.Socket"/></socket>
		<input public="1"><c path="sys.net.Socket"/></input>
		<port public="1"><x path="Int"/></port>
		<message public="1"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></message>
		<bind public="1" set="method" line="18"><f a=""><x path="Void"/></f></bind>
		<update public="1" set="method" line="24"><f a=""><x path="Void"/></f></update>
		<send public="1" set="method" line="34"><f a="string">
	<c path="String"/>
	<x path="Void"/>
</f></send>
		<sendCompress public="1" set="method" line="40"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></sendCompress>
		<new public="1" set="method" line="14">
			<f a="?port" v="8005">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ port : 8005 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="console.Command" params="" file="src/console/Command.hx">
		<Lib expr="{ }">
			<d/>
			<meta><m n=":value"><e>{ }</e></m></meta>
		</Lib>
		<run public="1" set="method" line="15"><f a="string">
	<c path="String"/>
	<x path="Bool"/>
</f></run>
		<url public="1" set="method" line="69"><f a="string">
	<c path="String"/>
	<x path="Void"/>
</f></url>
		<execUrl public="1" set="method" line="78"><f a="url">
	<c path="String"/>
	<x path="Void"/>
</f></execUrl>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="console.Console" params="" file="src/console/Console.hx">
		<length expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</length>
		<parser><c path="hscript.Parser"/></parser>
		<interp><c path="console._Console.Interp"/></interp>
		<history expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</history>
		<command><c path="console.Command"/></command>
		<debug public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</debug>
		<set public="1" set="method" line="67"><f a="name:value">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></set>
		<print public="1" set="method" line="71"><f a="inp:out">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></print>
		<previous public="1" set="method" line="145"><f a=""><x path="Void"/></f></previous>
		<run public="1" set="method" line="171"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></run>
		<getFields set="method" line="183"><f a="Object">
	<d/>
	<c path="Array"><c path="String"/></c>
</f></getFields>
		<new public="1" set="method" line="27"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hscript.Interp" params="" file="/usr/local/lib/haxe/lib/hscript/2,3,0/hscript/Interp.hx">
		<variables public="1"><t path="Map">
	<c path="String"/>
	<d/>
</t></variables>
		<locals><t path="Map">
	<c path="String"/>
	<a><r><d/></r></a>
</t></locals>
		<binops><t path="Map">
	<c path="String"/>
	<f a=":">
		<e path="hscript.Expr"/>
		<e path="hscript.Expr"/>
		<d/>
	</f>
</t></binops>
		<depth><x path="Int"/></depth>
		<inTry><x path="Bool"/></inTry>
		<declared><c path="Array"><a>
	<old><a><r><d/></r></a></old>
	<n><c path="String"/></n>
</a></c></declared>
		<returnValue><d/></returnValue>
		<posInfos public="1" set="method" line="74"><f a=""><t path="haxe.PosInfos"/></f></posInfos>
		<initOps set="method" line="82"><f a=""><x path="Void"/></f></initOps>
		<assign set="method" line="123"><f a="e1:e2">
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
	<d/>
</f></assign>
		<assignOp set="method" line="150"><f a="op:fop">
	<c path="String"/>
	<f a=":">
		<d/>
		<d/>
		<d/>
	</f>
	<x path="Void"/>
</f></assignOp>
		<evalAssignOp set="method" line="155"><f a="op:fop:e1:e2">
	<c path="String"/>
	<f a=":">
		<d/>
		<d/>
		<unknown/>
	</f>
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
	<d/>
</f></evalAssignOp>
		<increment set="method" line="186"><f a="e:prefix:delta">
	<e path="hscript.Expr"/>
	<x path="Bool"/>
	<x path="Int"/>
	<d/>
</f></increment>
		<execute public="1" set="method" line="238"><f a="expr">
	<e path="hscript.Expr"/>
	<d/>
</f></execute>
		<exprReturn set="method" line="249"><f a="e">
	<e path="hscript.Expr"/>
	<d/>
</f></exprReturn>
		<duplicate params="T" set="method" line="265"><f a="h">
	<t path="Map">
		<c path="String"/>
		<c path="duplicate.T"/>
	</t>
	<x path="haxe.ds.Map">
		<c path="String"/>
		<x path="Null"><c path="duplicate.T"/></x>
	</x>
</f></duplicate>
		<restore set="method" line="276"><f a="old">
	<x path="Int"/>
	<x path="Void"/>
</f></restore>
		<error get="inline" set="null" line="283">
			<f a="e:?rethrow" v=":false">
				<e path="hscript.Error"/>
				<x path="Bool"/>
				<d/>
			</f>
			<meta><m n=":value"><e>{ rethrow : false }</e></m></meta>
		</error>
		<rethrow get="inline" set="null" line="289"><f a="e">
	<d/>
	<x path="Void"/>
</f></rethrow>
		<resolve set="method" line="297"><f a="id">
	<c path="String"/>
	<d/>
</f></resolve>
		<expr public="1" set="method" line="307"><f a="e">
	<e path="hscript.Expr"/>
	<d/>
</f></expr>
		<doWhileLoop set="method" line="575"><f a="econd:e">
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
	<x path="Void"/>
</f></doWhileLoop>
		<whileLoop set="method" line="592"><f a="econd:e">
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
	<x path="Void"/>
</f></whileLoop>
		<makeIterator set="method" line="608"><f a="v">
	<d/>
	<t path="Iterator"><d/></t>
</f></makeIterator>
		<forLoop set="method" line="618"><f a="n:it:e">
	<c path="String"/>
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
	<x path="Void"/>
</f></forLoop>
		<isMap get="inline" set="null" line="637"><f a="o">
	<d/>
	<x path="Bool"/>
</f></isMap>
		<getMapValue get="inline" set="null" line="641"><f a="map:key">
	<d/>
	<d/>
	<d/>
</f></getMapValue>
		<setMapValue get="inline" set="null" line="645"><f a="map:key:value">
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></setMapValue>
		<get set="method" line="649"><f a="o:f">
	<d/>
	<c path="String"/>
	<d/>
</f></get>
		<set set="method" line="665"><f a="o:f:v">
	<d/>
	<c path="String"/>
	<d/>
	<d/>
</f></set>
		<fcall set="method" line="671"><f a="o:f:args">
	<d/>
	<c path="String"/>
	<c path="Array"><d/></c>
	<d/>
</f></fcall>
		<call set="method" line="675"><f a="o:f:args">
	<d/>
	<d/>
	<c path="Array"><d/></c>
	<d/>
</f></call>
		<cnew set="method" line="679"><f a="cl:args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<d/>
</f></cnew>
		<new public="1" set="method" line="53"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="console._Console.Interp" params="" file="src/console/Console.hx" private="1" module="console.Console">
		<extends path="hscript.Interp"/>
		<getGlobals public="1" set="method" line="217"><f a=""><c path="Array"><c path="String"/></c></f></getGlobals>
		<toArray params="T" set="method" line="222"><f a="iterator">
	<t path="Iterator"><c path="toArray.T"/></t>
	<c path="Array"><c path="toArray.T"/></c>
</f></toArray>
		<get set="method" line="230" override="1"><f a="o:f">
	<d/>
	<c path="String"/>
	<d/>
</f></get>
		<set set="method" line="237" override="1"><f a="o:f:v">
	<d/>
	<c path="String"/>
	<d/>
	<d/>
</f></set>
		<new public="1" set="method" line="215"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="console.Program" params="" file="src/console/Program.hx">
		<goal public="1" expr="new Pos()">
			<c path="console.Pos"/>
			<meta><m n=":value"><e>new Pos()</e></m></meta>
		</goal>
		<home public="1" expr="new Pos()">
			<c path="console.Pos"/>
			<meta><m n=":value"><e>new Pos()</e></m></meta>
		</home>
		<setup public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</setup>
		<useRange public="1" expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</useRange>
		<diagnol public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</diagnol>
		<useX public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</useX>
		<useY public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</useY>
		<ate public="1" expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</ate>
		<repeatTimer><c path="haxe.Timer"/></repeatTimer>
		<actions expr="[]">
			<c path="Array"><t path="console.Action"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</actions>
		<action expr="null">
			<t path="console.Action"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</action>
		<console public="1"><c path="console.Console"/></console>
		<taskName public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</taskName>
		<range public="1" expr="30">
			<x path="Int"/>
			<meta><m n=":value"><e>30</e></m></meta>
		</range>
		<send public="1" set="method" line="38">
			<f a="tag:x:y:?data:?moveSensitive" v=":::&quot;&quot;:true">
				<x path="server.ServerTag"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ moveSensitive : true, data : "" }</e></m></meta>
		</send>
		<clean public="1" set="method" line="51"><f a=""><x path="Void"/></f></clean>
		<update public="1" set="method" line="61"><f a=""><x path="Void"/></f></update>
		<preform set="method" line="65"><f a="i">
	<x path="Int"/>
	<x path="Void"/>
</f></preform>
		<end public="1" set="method" line="73"><f a=""><x path="Void"/></f></end>
		<run public="1" set="method" line="110"><f a=""><x path="Void"/></f></run>
		<setHome public="1" set="method" line="136">
			<f a="?x:?y" v="0:0">
				<x path="Int"/>
				<x path="Int"/>
				<c path="console.Program"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</setHome>
		<path set="method" line="152"><f a="refine">
	<x path="Bool"/>
	<x path="Void"/>
</f></path>
		<refineUse set="method" line="170"><f a=""><x path="Void"/></f></refineUse>
		<refineBlock set="method" line="211"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></refineBlock>
		<kill public="1" set="method" line="215">
			<f a="?x:?y:?id" v="null:0:null">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ id : null, y : 0, x : null }</e></m></meta>
		</kill>
		<grave public="1" set="method" line="229"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></grave>
		<owner public="1" set="method" line="233"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></owner>
		<drop public="1" set="method" line="237">
			<f a="?x:?y:?c" v="null:0:-1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="console.Program"/>
			</f>
			<meta><m n=":value"><e>{ c : -1, y : 0, x : null }</e></m></meta>
		</drop>
		<use public="1" set="method" line="248">
			<f a="?x:?y" v="null:null">
				<x path="Int"/>
				<x path="Int"/>
				<c path="console.Program"/>
			</f>
			<meta><m n=":value"><e>{ y : null, x : null }</e></m></meta>
		</use>
		<goto public="1" set="method" line="258">
			<f a="name:?refine:?optimize" v=":true:true">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="console.Program"/>
			</f>
			<meta><m n=":value"><e>{ optimize : true, refine : true }</e></m></meta>
		</goto>
		<events public="1" set="method" line="270"><f a="finish:fail">
	<f a=""><x path="Void"/></f>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></events>
		<type set="method" line="278"><f a="id:property">
	<x path="Int"/>
	<c path="String"/>
	<x path="Bool"/>
</f></type>
		<findList set="method" line="289">
			<f a="get:?optimize" v=":true">
				<c path="Array"><x path="Int"/></c>
				<x path="Bool"/>
				<c path="console.Pos"/>
			</f>
			<meta><m n=":value"><e>{ optimize : true }</e></m></meta>
		</findList>
		<max public="1" set="method" line="331"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></max>
		<min public="1" set="method" line="336"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></min>
		<emote public="1" set="method" line="341"><f a="e">
	<x path="Int"/>
	<c path="console.Program"/>
</f></emote>
		<say public="1" set="method" line="347"><f a="string">
	<c path="String"/>
	<c path="console.Program"/>
</f></say>
		<remove public="1" set="method" line="352">
			<f a="x:y:?index" v="::-1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="console.Program"/>
			</f>
			<meta><m n=":value"><e>{ index : -1 }</e></m></meta>
		</remove>
		<specialRemove public="1" set="method" line="358">
			<f a="?i" v="-1">
				<x path="Int"/>
				<c path="console.Program"/>
			</f>
			<meta><m n=":value"><e>{ i : -1 }</e></m></meta>
		</specialRemove>
		<inventory public="1" set="method" line="362">
			<f a="i:?index" v=":-1">
				<x path="Int"/>
				<x path="Int"/>
				<c path="console.Program"/>
			</f>
			<meta><m n=":value"><e>{ index : -1 }</e></m></meta>
		</inventory>
		<pull public="1" set="method" line="366">
			<f a="i:?index" v=":-1">
				<x path="Int"/>
				<x path="Int"/>
				<c path="console.Program"/>
			</f>
			<meta><m n=":value"><e>{ index : -1 }</e></m></meta>
		</pull>
		<baby public="1" set="method" line="372"><f a="x:y">
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
	<c path="console.Program"/>
</f></baby>
		<jump public="1" set="method" line="383"><f a=""><c path="console.Program"/></f></jump>
		<ubaby public="1" set="method" line="388">
			<f a="x:y:?index" v="::-1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="console.Program"/>
			</f>
			<meta><m n=":value"><e>{ index : -1 }</e></m></meta>
		</ubaby>
		<self public="1" set="method" line="396">
			<f a="?index" v="-1">
				<x path="Int"/>
				<c path="console.Program"/>
			</f>
			<meta><m n=":value"><e>{ index : -1 }</e></m></meta>
		</self>
		<task public="1" set="method" line="402"><f a="name">
	<c path="String"/>
	<c path="console.Program"/>
</f></task>
		<die public="1" set="method" line="420"><f a=""><c path="console.Program"/></f></die>
		<distance public="1" set="method" line="425"><f a="a:b">
	<c path="console.Pos"/>
	<c path="console.Pos"/>
	<x path="Bool"/>
</f></distance>
		<sub public="1" set="method" line="440"><f a="a:b">
	<c path="console.Pos"/>
	<c path="console.Pos"/>
	<c path="console.Pos"/>
</f></sub>
		<step public="1" set="method" line="447"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<c path="console.Program"/>
</f></step>
		<new public="1" set="method" line="34"><f a="console">
	<c path="console.Console"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="console.Pos" params="" file="src/console/Program.hx" module="console.Program">
		<x public="1"><x path="Int"/></x>
		<y public="1"><x path="Int"/></y>
		<clone public="1" set="method" line="515"><f a=""><c path="console.Pos"/></f></clone>
		<new public="1" set="method" line="511"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="console.Action" params="" file="src/console/Program.hx" module="console.Program"><a>
	<type><x path="Int"/></type>
	<tag><c path="Array"><x path="server.ServerTag"/></c></tag>
	<property><c path="String"/></property>
	<finish><f a=""><x path="Void"/></f></finish>
	<fail><f a=""><x path="Void"/></f></fail>
	<data><c path="Array"><c path="String"/></c></data>
</a></typedef>
	<class path="console.Util" params="" file="src/console/Util.hx">
		<object public="1" set="method" line="14" static="1"><f a="i">
	<x path="Int"/>
	<x path="Void"/>
</f></object>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="data.ArrayDataArray" params="T" file="src/data/ArrayDataArray.hx">
		<array expr="[]">
			<c path="Array"><c path="Array"><c path="Array"><c path="data.ArrayDataArray.T"/></c></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</array>
		<dx public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</dx>
		<dy public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</dy>
		<clear public="1" set="method" line="14"><f a=""><x path="Void"/></f></clear>
		<get public="1" set="method" line="20"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><c path="data.ArrayDataArray.T"/></c>
</f></get>
		<shiftY public="1" set="method" line="28"><f a="y">
	<x path="Int"/>
	<x path="Void"/>
</f></shiftY>
		<shiftX public="1" set="method" line="37"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></shiftX>
		<set public="1" set="method" line="52"><f a="x:y:value">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><c path="data.ArrayDataArray.T"/></c>
	<x path="Void"/>
</f></set>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<meta><m n=":generic"/></meta>
	</class>
	<class path="data.ArrayDataInt" params="" file="src/data/ArrayDataArray.hx" module="data.ArrayDataArray">
		<NAN public="1" get="inline" set="null" expr="-1" line="67" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</NAN>
		<array expr="[]">
			<c path="Array"><c path="Array"><x path="Int"/></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</array>
		<dx public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</dx>
		<dy public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</dy>
		<clear public="1" set="method" line="72"><f a=""><x path="Void"/></f></clear>
		<row public="1" set="method" line="78"><f a="y">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></row>
		<get public="1" set="method" line="82"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<shiftY public="1" set="method" line="90"><f a="y">
	<x path="Int"/>
	<x path="Void"/>
</f></shiftY>
		<shiftX public="1" set="method" line="99"><f a="x:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></shiftX>
		<set public="1" set="method" line="114"><f a="x:y:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
		<new public="1" set="method" line="68"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="data.GameData" params="" file="src/data/GameData.hx">
		<blocking public="1" expr="new Map&lt;String,Bool&gt;()">
			<t path="Map">
				<c path="String"/>
				<x path="Bool"/>
			</t>
			<meta><m n=":value"><e><![CDATA[new Map<String,Bool>()]]></e></m></meta>
		</blocking>
		<playerMap public="1" expr="new Map&lt;Int,Player&gt;()">
			<t path="Map">
				<x path="Int"/>
				<c path="game.Player"/>
			</t>
			<meta><m n=":value"><e><![CDATA[new Map<Int,Player>()]]></e></m></meta>
		</playerMap>
		<transitionData public="1"><c path="data.TransitionData"/></transitionData>
		<map public="1"><c path="data.MapData"/></map>
		<spriteMap public="1" expr="new Map&lt;Int,SpriteData&gt;()">
			<t path="Map">
				<x path="Int"/>
				<c path="data.SpriteData"/>
			</t>
			<meta><m n=":value"><e><![CDATA[new Map<Int,SpriteData>()]]></e></m></meta>
		</spriteMap>
		<objectMap public="1" expr="new Map&lt;Int,ObjectData&gt;()">
			<t path="Map">
				<x path="Int"/>
				<c path="data.ObjectData"/>
			</t>
			<meta><m n=":value"><e><![CDATA[new Map<Int,ObjectData>()]]></e></m></meta>
		</objectMap>
		<objectAlt public="1" expr="new Map&lt;Int,Int&gt;()">
			<t path="Map">
				<x path="Int"/>
				<x path="Int"/>
			</t>
			<meta><m n=":value"><e><![CDATA[new Map<Int,Int>()]]></e></m></meta>
		</objectAlt>
		<nextObjectNumber public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</nextObjectNumber>
		<objectData set="method" line="60"><f a=""><x path="Void"/></f></objectData>
		<new public="1" set="method" line="36"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="data.LineReader" params="" file="src/data/LineReader.hx">
		<line><x path="haxe.ds.Vector"><c path="String"/></x></line>
		<next expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</next>
		<input><c path="haxe.io.Input"/></input>
		<readLines public="1" set="method" line="15"><f a="string">
	<c path="String"/>
	<x path="Void"/>
</f></readLines>
		<getFloatArray public="1" set="method" line="20"><f a=""><c path="Array"><x path="Float"/></c></f></getFloatArray>
		<getIntArray public="1" set="method" line="29"><f a=""><c path="Array"><x path="Int"/></c></f></getIntArray>
		<getStringArray public="1" set="method" line="38"><f a=""><c path="Array"><c path="String"/></c></f></getStringArray>
		<getPoint public="1" set="method" line="42"><f a=""><c path="data.Point"/></f></getPoint>
		<getBool public="1" set="method" line="48"><f a=""><x path="Bool"/></f></getBool>
		<getInt public="1" set="method" line="52"><f a=""><x path="Int"/></f></getInt>
		<getArrayInt public="1" set="method" line="56"><f a=""><c path="Array"><x path="Int"/></c></f></getArrayInt>
		<getFloat public="1" set="method" line="73"><f a=""><x path="Float"/></f></getFloat>
		<getString public="1" set="method" line="77"><f a=""><c path="String"/></f></getString>
		<readName public="1" set="method" line="88"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></readName>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="data.MapData" params="" file="src/data/MapData.hx">
		<id public="1" set="method" line="69" static="1"><f a="string">
	<c path="String"/>
	<c path="Array"><x path="Int"/></c>
</f></id>
		<containers public="1" expr="[]">
			<c path="Array"><x path="haxe.ds.Vector"><x path="Int"/></x></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</containers>
		<biome public="1" expr="new ArrayDataInt()">
			<c path="data.ArrayDataInt"/>
			<meta><m n=":value"><e>new ArrayDataInt()</e></m></meta>
		</biome>
		<floor public="1" expr="new ArrayDataInt()">
			<c path="data.ArrayDataInt"/>
			<meta><m n=":value"><e>new ArrayDataInt()</e></m></meta>
		</floor>
		<object public="1" expr="new ArrayDataArray&lt;Int&gt;()">
			<c path="data.ArrayDataArray_Int"/>
			<meta><m n=":value"><e><![CDATA[new ArrayDataArray<Int>()]]></e></m></meta>
		</object>
		<loaded public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</loaded>
		<valleyOffsetY public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</valleyOffsetY>
		<valleyOffsetX public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</valleyOffsetX>
		<valleySpacing public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</valleySpacing>
		<valleyBool public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</valleyBool>
		<offsetX public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</offsetX>
		<offsetY public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</offsetY>
		<offsetBoolX public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</offsetBoolX>
		<offsetBoolY public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</offsetBoolY>
		<x public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</x>
		<y public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</y>
		<width public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</width>
		<height public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</height>
		<setRect public="1" set="method" line="45"><f a="x:y:width:height:string">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></setRect>
		<new public="1" set="method" line="41"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="data.MapInstance" params="" file="src/data/MapData.hx" module="data.MapData">
		<x public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</x>
		<y public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</y>
		<width public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</width>
		<height public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</height>
		<rawSize public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</rawSize>
		<compressedSize public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</compressedSize>
		<toString public="1" set="method" line="107"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="103"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="data.MapChange" params="" file="src/data/MapData.hx" module="data.MapData">
		<x public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</x>
		<y public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</y>
		<floor public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</floor>
		<id public="1" expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</id>
		<pid public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</pid>
		<oldX public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</oldX>
		<oldY public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</oldY>
		<speed public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</speed>
		<toString public="1" set="method" line="139"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="122"><f a="array">
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="data.ObjectCode" params="" file="src/data/ObjectCode.hx">
		<spring expr="[3030, 3031, 3032, 3033, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3044, 1096, 662, 663, 664, 665, 1861, 2388, 2389, 2390]" line="5" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[3030, 3031, 3032, 3033, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3044, 1096, 662, 663, 664, 665, 1861, 2388, 2389, 2390]</e></m></meta>
		</spring>
		<rift expr="[]" line="6" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</rift>
		<look public="1" set="method" line="7" static="1"><f a="id">
	<x path="Int"/>
	<x path="Void"/>
</f></look>
		<id public="1" set="method" line="11" static="1"><f a="name">
	<c path="String"/>
	<c path="Array"><x path="Int"/></c>
</f></id>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="data.ObjectType" params="" file="src/data/ObjectData.hx" module="data.ObjectData">
		<OBJECT/>
		<FLOOR/>
		<PLAYER/>
		<GROUND/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="data.ObjectData" params="" file="src/data/ObjectData.hx">
		<extends path="data.LineReader"/>
		<CLOTHING_PIECES public="1" get="inline" set="null" expr="6" line="15" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</CLOTHING_PIECES>
		<toolsetRecord public="1" expr="[]" line="347" static="1">
			<c path="Array"><t path="data.ToolSetRecord"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</toolsetRecord>
		<id public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</id>
		<description public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</description>
		<containable public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</containable>
		<containSize public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</containSize>
		<noFlip public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</noFlip>
		<sideAcess public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</sideAcess>
		<vertSlotRot public="1" expr="0.000000">
			<x path="Float"/>
			<meta><m n=":value"><e>0.000000</e></m></meta>
		</vertSlotRot>
		<permanent public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</permanent>
		<minPickupAge public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</minPickupAge>
		<heldInHand public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</heldInHand>
		<rideable public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</rideable>
		<blocksWalking public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</blocksWalking>
		<leftBlockingRadius public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</leftBlockingRadius>
		<rightBlockingRadius public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</rightBlockingRadius>
		<drawBehindPlayer public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</drawBehindPlayer>
		<mapChance public="1" expr="0.000000">
			<x path="Float"/>
			<meta><m n=":value"><e>0.000000</e></m></meta>
		</mapChance>
		<heatValue public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</heatValue>
		<rValue public="1" expr="0.000000">
			<x path="Float"/>
			<meta><m n=":value"><e>0.000000</e></m></meta>
		</rValue>
		<person public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</person>
		<noSpawn public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</noSpawn>
		<male public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</male>
		<deathMarker public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</deathMarker>
		<homeMarker public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</homeMarker>
		<floor public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</floor>
		<floorHugging public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</floorHugging>
		<foodValue public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</foodValue>
		<speedMult public="1" expr="1.000000">
			<x path="Float"/>
			<meta><m n=":value"><e>1.000000</e></m></meta>
		</speedMult>
		<heldOffset public="1"><c path="data.Point"/></heldOffset>
		<clothing public="1" expr="&quot;n&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"n"</e></m></meta>
		</clothing>
		<clothingOffset public="1"><c path="data.Point"/></clothingOffset>
		<deadlyDistance public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</deadlyDistance>
		<useDistance public="1" expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</useDistance>
		<creationSoundInitialOnly public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</creationSoundInitialOnly>
		<creationSoundForce public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</creationSoundForce>
		<numSlots public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</numSlots>
		<timeStretch public="1" expr="1.000000">
			<x path="Float"/>
			<meta><m n=":value"><e>1.000000</e></m></meta>
		</timeStretch>
		<slotSize public="1" expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</slotSize>
		<slotsLocked public="1" expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</slotsLocked>
		<slotPos public="1"><x path="haxe.ds.Vector"><c path="data.Point"/></x></slotPos>
		<slotVert public="1"><x path="haxe.ds.Vector"><x path="Bool"/></x></slotVert>
		<slotParent public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></slotParent>
		<numSprites public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</numSprites>
		<spriteArray public="1"><x path="haxe.ds.Vector"><c path="data.SpriteData"/></x></spriteArray>
		<headIndex public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</headIndex>
		<bodyIndex public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</bodyIndex>
		<backFootIndex public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</backFootIndex>
		<frontFootIndex public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</frontFootIndex>
		<eyesIndex public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</eyesIndex>
		<mouthIndex public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</mouthIndex>
		<eyesOffset public="1" expr="null">
			<c path="data.Point"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</eyesOffset>
		<numUses public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</numUses>
		<useChance public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</useChance>
		<useVanishIndex public="1" expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</useVanishIndex>
		<useAppearIndex public="1" expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</useAppearIndex>
		<cacheHeight public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</cacheHeight>
		<apocalypseTrigger public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</apocalypseTrigger>
		<monumentStep public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</monumentStep>
		<monumentDone public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</monumentDone>
		<monumentCall public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</monumentCall>
		<toolSetIndex public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</toolSetIndex>
		<toolLearned public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</toolLearned>
		<fail public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</fail>
		<read public="1" set="method" line="116"><f a=""><x path="Void"/></f></read>
		<getSpriteData public="1" set="method" line="310"><f a=""><x path="Void"/></f></getSpriteData>
		<new public="1" set="method" line="99">
			<f a="?i" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ i : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="data.ToolSetRecord" params="" file="src/data/ObjectData.hx" module="data.ObjectData"><a>
	<setTag><c path="String"/></setTag>
	<setMembership><c path="Array"><x path="Int"/></c></setMembership>
</a></typedef>
	<class path="data.PlayerData" params="" file="src/data/PlayerData.hx">
		<key public="1" expr="new Map&lt;Int,PlayerType&gt;()">
			<t path="Map">
				<x path="Int"/>
				<c path="data.PlayerType"/>
			</t>
			<meta><m n=":value"><e><![CDATA[new Map<Int,PlayerType>()]]></e></m></meta>
		</key>
		<array public="1" expr="[]">
			<c path="Array"><c path="data.PlayerType"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</array>
		<primary public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</primary>
		<update public="1"><f a=""><x path="Void"/></f></update>
		<new public="1" set="method" line="23"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="data.PlayerType" params="" file="src/data/PlayerData.hx" module="data.PlayerData">
		<p_id public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</p_id>
		<po_id public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</po_id>
		<facing public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</facing>
		<action public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</action>
		<action_target_x public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</action_target_x>
		<action_target_y public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</action_target_y>
		<o_id public="1"><c path="Array"><x path="Int"/></c></o_id>
		<o_origin_valid public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</o_origin_valid>
		<o_origin_x public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</o_origin_x>
		<o_origin_y public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</o_origin_y>
		<o_transition_source_id public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</o_transition_source_id>
		<heat public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</heat>
		<done_moving_seqNum public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</done_moving_seqNum>
		<forced public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</forced>
		<x public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</x>
		<y public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</y>
		<age public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</age>
		<age_r public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</age_r>
		<move_speed public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</move_speed>
		<clothing_set public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</clothing_set>
		<just_ate public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</just_ate>
		<last_ate_id public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</last_ate_id>
		<responsible_id public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</responsible_id>
		<held_yum public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</held_yum>
		<held_learned public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</held_learned>
		<toString public="1" set="method" line="62"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="58"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="data.PlayerInstance" params="" file="src/data/PlayerData.hx" module="data.PlayerData">
		<extends path="data.PlayerType"/>
		<new public="1" set="method" line="74"><f a="a">
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="data.PlayerMove" params="" file="src/data/PlayerData.hx" module="data.PlayerData">
		<id public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</id>
		<xs expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</xs>
		<ys expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ys>
		<total expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</total>
		<current expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</current>
		<trunc expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</trunc>
		<moves expr="[]">
			<c path="Array"><a>
	<y><x path="Int"/></y>
	<x><x path="Int"/></x>
</a></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</moves>
		<movePlayer public="1" set="method" line="185"><f a="player">
	<c path="game.Player"/>
	<x path="Void"/>
</f></movePlayer>
		<new public="1" set="method" line="150"><f a="a">
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="data.Point" params="" file="src/data/Point.hx">
		<x public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</x>
		<y public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</y>
		<new public="1" set="method" line="7">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="data.SpriteData" params="" file="src/data/SpriteData.hx">
		<name public="1"><c path="String"/></name>
		<spriteID public="1" expr="54">
			<x path="Int"/>
			<meta><m n=":value"><e>54</e></m></meta>
		</spriteID>
		<pos public="1"><c path="data.Point"/></pos>
		<rot public="1" expr="0.000000">
			<x path="Float"/>
			<meta><m n=":value"><e>0.000000</e></m></meta>
		</rot>
		<hFlip public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</hFlip>
		<color public="1" expr="[]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</color>
		<ageRange public="1" expr="[]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</ageRange>
		<parent public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</parent>
		<invisHolding public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</invisHolding>
		<invisWordn public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</invisWordn>
		<behindSlots public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</behindSlots>
		<invisCont public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</invisCont>
		<inCenterXOffset public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</inCenterXOffset>
		<inCenterYOffset public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</inCenterYOffset>
		<new public="1" set="method" line="20"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="data.TransitionData" params="" file="src/data/TransitionData.hx">
		<transitions expr="[]">
			<c path="Array"><c path="data.Transition"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</transitions>
		<new public="1" set="method" line="9"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="data.Transition" params="" file="src/data/TransitionData.hx" module="data.TransitionData">
		<lastUseActor public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</lastUseActor>
		<lastUseTarget public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</lastUseTarget>
		<actorID public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</actorID>
		<targetID public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</targetID>
		<newActorID public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</newActorID>
		<newTargetID public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</newTargetID>
		<autoDecaySeconds public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</autoDecaySeconds>
		<actorMinUseFraction public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</actorMinUseFraction>
		<targetMinUseFraction public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</targetMinUseFraction>
		<reverseUseActor public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</reverseUseActor>
		<reverseUseTarget public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</reverseUseTarget>
		<move public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</move>
		<desireMoveDist public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</desireMoveDist>
		<noUseActor public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</noUseActor>
		<noUseTarget public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</noUseTarget>
		<playerActor public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</playerActor>
		<tool public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</tool>
		<targetRemains public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</targetRemains>
		<decay public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</decay>
		<new public="1" set="method" line="41"><f a="name:string">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="debug.Profiler" params="" file="src/debug/Profiler.hx">
		<start public="1" set="method" line="37" static="1"><f a="string">
	<c path="String"/>
	<x path="Void"/>
</f></start>
		<stop public="1" set="method" line="38" static="1"><f a=""><x path="Void"/></f></stop>
		<currentTime><x path="Float"/></currentTime>
		<times expr="[]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</times>
		<cacheCount expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</cacheCount>
		<fps public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</fps>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="game.Player" params="" file="src/game/Player.hx">
		<instance public="1"><c path="data.PlayerInstance"/></instance>
		<clothingInt expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</clothingInt>
		<lastMove public="1" expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</lastMove>
		<moveTimer public="1"><c path="haxe.Timer"/></moveTimer>
		<moving public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</moving>
		<goal public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</goal>
		<moves public="1" expr="[]">
			<c path="Array"><c path="console.Pos"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</moves>
		<program public="1" expr="null">
			<c path="console.Program"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</program>
		<follow public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</follow>
		<multi expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</multi>
		<ix public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ix>
		<iy public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</iy>
		<oid public="1" expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</oid>
		<held public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</held>
		<ageInt public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ageInt>
		<firstName public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</firstName>
		<lastName public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</lastName>
		<text public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</text>
		<inRange public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</inRange>
		<motion public="1" set="method" line="104"><f a=""><x path="Void"/></f></motion>
		<step public="1" set="method" line="170"><f a="mx:my">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></step>
		<computePathSpeedMod public="1" set="method" line="185"><f a=""><x path="Float"/></f></computePathSpeedMod>
		<measurePathLength public="1" set="method" line="195"><f a=""><x path="Float"/></f></measurePathLength>
		<equal public="1" set="method" line="217"><f a="pos:pos2">
	<c path="console.Pos"/>
	<c path="console.Pos"/>
	<x path="Bool"/>
</f></equal>
		<sub public="1" set="method" line="222"><f a="pos:pos2">
	<c path="console.Pos"/>
	<c path="console.Pos"/>
	<c path="console.Pos"/>
</f></sub>
		<px public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</px>
		<py public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</py>
		<path public="1" set="method" line="231"><f a=""><x path="Void"/></f></path>
		<setPath public="1" set="method" line="241"><f a=""><x path="Bool"/></f></setPath>
		<pathfind public="1" set="method" line="259"><f a="px:py">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></pathfind>
		<force public="1" set="method" line="282"><f a=""><x path="Void"/></f></force>
		<set public="1" set="method" line="295"><f a="data">
	<c path="data.PlayerInstance"/>
	<x path="Void"/>
</f></set>
		<cloths public="1" set="method" line="334"><f a=""><x path="Void"/></f></cloths>
		<hold public="1" set="method" line="367"><f a=""><x path="Void"/></f></hold>
		<new public="1" set="method" line="61"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="haxe.Function" params="" file="/usr/local/lib/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="/usr/local/lib/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Constructible" params="T" file="/usr/local/lib/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc><![CDATA[This type unifies with any instance of classes that have a constructor
	which

	  * is `public` and
	  * unifies with the type used for type parameter `T`.

	If a type parameter `A` is assigned to a type parameter `B` which is constrained
	to `Constructible<T>`, A must be explicitly constrained to
	`Constructible<T>` as well.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.]]></haxe_doc>
		<impl><class path="haxe._Constraints.Constructible_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.IMap" params="K:V" file="/usr/local/lib/haxe/std/haxe/Constraints.hx" module="haxe.Constraints" interface="1">
		<get public="1" set="method"><f a="k">
	<c path="haxe.IMap.K"/>
	<x path="Null"><c path="haxe.IMap.V"/></x>
</f></get>
		<set public="1" set="method"><f a="k:v">
	<c path="haxe.IMap.K"/>
	<c path="haxe.IMap.V"/>
	<x path="Void"/>
</f></set>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.DynamicAccess" params="T" file="/usr/local/lib/haxe/std/haxe/DynamicAccess.hx">
		<from><icast><d><c path="haxe.DynamicAccess.T"/></d></icast></from>
		<this><d><c path="haxe.DynamicAccess.T"/></d></this>
		<to><icast><d><c path="haxe.DynamicAccess.T"/></d></icast></to>
		<haxe_doc>DynamicAccess is an abstract type for working with anonymous structures
	that are intended to hold collections of objects by the string key.

	For example, these types of structures are often created from JSON.

	Basically, it wraps `Reflect` calls in a `Map`-like interface.</haxe_doc>
		<impl><class path="haxe._DynamicAccess.DynamicAccess_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/DynamicAccess.hx" private="1" module="haxe.DynamicAccess"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="sys.thread.Mutex" params="" file="/usr/local/lib/haxe/std/neko/_std/sys/thread/Mutex.hx">
		<mutex_create expr="neko.Lib.loadLazy(&quot;std&quot;, &quot;mutex_create&quot;, 0)" line="45" static="1">
			<f a=""><unknown/></f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("std", "mutex_create", 0)</e></m></meta>
		</mutex_create>
		<mutex_release expr="neko.Lib.loadLazy(&quot;std&quot;, &quot;mutex_release&quot;, 1)" line="46" static="1">
			<f a="">
				<d/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("std", "mutex_release", 1)</e></m></meta>
		</mutex_release>
		<mutex_acquire expr="neko.Lib.loadLazy(&quot;std&quot;, &quot;mutex_acquire&quot;, 1)" line="47" static="1">
			<f a="">
				<d/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("std", "mutex_acquire", 1)</e></m></meta>
		</mutex_acquire>
		<m><d/></m>
		<acquire public="1" set="method" line="33">
			<f a=""><x path="Void"/></f>
			<haxe_doc>The current thread acquire the mutex or wait if not available.
		The same thread can acquire several times the same mutex but
		must release it as many times it has been acquired.</haxe_doc>
		</acquire>
		<release public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Release a mutex that has been acquired by the current thread.
		The behavior is undefined if the current thread does not own
		the mutex.</haxe_doc>
		</release>
		<new public="1" set="method" line="29">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a mutex.</haxe_doc>
		</new>
		<haxe_doc>Creates a mutex, which can be used to acquire a temporary lock
	to access some ressource. The main difference with a lock is
	that a mutex must always be released by the owner thread.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.thread.Lock" params="" file="/usr/local/lib/haxe/std/neko/_std/sys/thread/Lock.hx">
		<lock_create expr="neko.Lib.load(&quot;std&quot;, &quot;lock_create&quot;, 0)" line="41" static="1">
			<f a=""><unknown/></f>
			<meta><m n=":value"><e>neko.Lib.load("std", "lock_create", 0)</e></m></meta>
		</lock_create>
		<lock_wait expr="neko.Lib.load(&quot;std&quot;, &quot;lock_wait&quot;, 2)" line="43" static="1">
			<f a=":">
				<d/>
				<x path="Null"><x path="Float"/></x>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "lock_wait", 2)</e></m></meta>
		</lock_wait>
		<l><d/></l>
		<wait public="1" set="method" line="33">
			<f a="?timeout">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Waits for the lock to be released, or `timeout` (in seconds)
		to expire. Returns `true` if the lock is released and `false`
		if a time-out occurs.</haxe_doc>
		</wait>
		<new public="1" set="method" line="29">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Lock which is initially locked.</haxe_doc>
		</new>
		<haxe_doc>A Lock allows blocking execution until it has been unlocked. It keeps track
	of how often `release` has been called, and blocks exactly as many `wait`
	calls.

	The order of the `release` and `wait` calls is irrelevant. That is, a Lock
	can be released before anyone waits for it. In that case, the `wait` call
	will execute immediately.

	Usage example:

	```
		var lock = new Lock();
		var elements = [1, 2, 3];
		for (element in elements) {
			// Create one thread per element
			new Thread(function() {
				trace(element);
				Sys.sleep(1);
				// Release once per thread = 3 times
				lock.release();
			});
		}
		for (_ in elements) {
			// Wait 3 times
			lock.wait();
		}
		trace("All threads finished");
	```</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.EntryPoint" params="" file="/usr/local/lib/haxe/std/haxe/EntryPoint.hx">
		<sleepLock expr="new Lock()" line="37" static="1">
			<c path="sys.thread.Lock"/>
			<meta><m n=":value"><e>new Lock()</e></m></meta>
		</sleepLock>
		<mutex expr="new Mutex()" line="38" static="1">
			<c path="sys.thread.Mutex"/>
			<meta><m n=":value"><e>new Mutex()</e></m></meta>
		</mutex>
		<pending expr="new Array&lt;Void&gt;()" line="40" static="1">
			<c path="Array"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Array<Void>()]]></e></m></meta>
		</pending>
		<threadCount public="1" set="null" expr="0" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</threadCount>
		<processEvents set="method" line="85" static="1"><f a=""><x path="Float"/></f></processEvents>
		<run public="1" set="method" line="108" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Start the main loop. Depending on the platform, this can return immediately or will only return when the application exits.</haxe_doc>
		</run>
		<haxe_doc>If `haxe.MainLoop` is kept from DCE, then we will insert an `haxe.EntryPoint.run()` call just at then end of `main()`.
	This class can be redefined by custom frameworks so they can handle their own main loop logic.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.EnumTools" params="" file="/usr/local/lib/haxe/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="52" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		
			pack1.pack2.(...).packN.EnumName

		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is `null`, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="65" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is `null`, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="81" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is `null`, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="98" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="110" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getConstructors>
		<haxe_doc>This class provides advanced methods on enums. It is ideally used with
	`using EnumTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `enum` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/usr/local/lib/haxe/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="133" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors (if there are any).

		If `a` or `b` are `null`, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="144" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="158" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is `[]`.

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="170" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getIndex>
		<haxe_doc>This class provides advanced methods on enum values. It is ideally used with
	`using EnumValueTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `EnumValue` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<typedef path="haxe.Http" params="" file="/usr/local/lib/haxe/std/haxe/Http.hx"><c path="sys.Http"/></typedef>
	<abstract path="haxe.Int32" params="" file="/usr/local/lib/haxe/std/haxe/Int32.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>Int32 provides a 32-bit integer with consistent overflow behavior across
	all platforms.</haxe_doc>
		<impl><class path="haxe._Int32.Int32_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/Int32.hx" private="1" module="haxe.Int32"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Int64" params="" file="/usr/local/lib/haxe/std/haxe/Int64.hx">
		<from>
			<icast><t path="haxe._Int64.__Int64"/></icast>
			<icast field="ofInt"><x path="Int"/></icast>
		</from>
		<this><t path="haxe._Int64.__Int64"/></this>
		<to><icast><t path="haxe._Int64.__Int64"/></icast></to>
		<haxe_doc>A cross-platform signed 64-bit integer.
	Int64 instances can be created from two 32-bit words using `Int64.make()`.</haxe_doc>
		<impl><class path="haxe._Int64.Int64_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64">
	<high public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</high>
	<low public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</low>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<typedef path="haxe._Int64.__Int64" params="" file="/usr/local/lib/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<c path="haxe._Int64.___Int64"/>
		<haxe_doc>This typedef will fool `@:coreApi` into thinking that we are using
	the same underlying type, even though it might be different on
	specific platforms.</haxe_doc>
	</typedef>
	<class path="haxe.Log" params="" file="/usr/local/lib/haxe/std/haxe/Log.hx">
		<formatOutput public="1" set="method" line="33" static="1">
			<f a="v:infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<c path="String"/>
			</f>
			<haxe_doc>Format the output of `trace` before printing it.</haxe_doc>
		</formatOutput>
		<trace public="1" set="dynamic" line="62" static="1">
			<f a="v:?infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the `trace()` call was made.

		This method can be rebound to a custom function:

			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v, ?infos) {
			  // handle trace
			}
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to `trace()` will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the `trace()` method, which is invoked upon a call to
	`trace()` in Haxe code.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.MainEvent" params="" file="/usr/local/lib/haxe/std/haxe/MainLoop.hx" module="haxe.MainLoop">
		<f><f a=""><x path="Void"/></f></f>
		<prev><c path="haxe.MainEvent"/></prev>
		<next><c path="haxe.MainEvent"/></next>
		<isBlocking public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>Tells if the event can lock the process from exiting (default:true)</haxe_doc>
		</isBlocking>
		<nextRun public="1" set="null"><x path="Float"/></nextRun>
		<priority public="1" set="null"><x path="Int"/></priority>
		<delay public="1" set="method" line="28">
			<f a="t">
				<x path="Null"><x path="Float"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>Delay the execution of the event for the given time, in seconds.
		If t is null, the event will be run at tick() time.</haxe_doc>
		</delay>
		<stop public="1" set="method" line="43">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Stop the event from firing anymore.</haxe_doc>
		</stop>
		<new set="method" line="18"><f a="f:p">
	<f a=""><x path="Void"/></f>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.MainLoop" params="" file="/usr/local/lib/haxe/std/haxe/MainLoop.hx">
		<pending static="1"><c path="haxe.MainEvent"/></pending>
		<threadCount public="1" get="null" set="null" static="1"><x path="Int"/></threadCount>
		<hasEvents public="1" set="method" line="66" static="1"><f a=""><x path="Bool"/></f></hasEvents>
		<add public="1" set="method" line="87" static="1">
			<f a="f:?priority" v=":0">
				<f a=""><x path="Void"/></f>
				<x path="Int"/>
				<c path="haxe.MainEvent"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0 }</e></m></meta>
			<haxe_doc>Add a pending event to be run into the main loop.</haxe_doc>
		</add>
		<sortEvents set="method" line="99" static="1"><f a=""><x path="Void"/></f></sortEvents>
		<tick set="method" line="164" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Run the pending events. Return the time for next event.</haxe_doc>
		</tick>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":access"><e>haxe.MainEvent</e></m>
		</meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/local/lib/haxe/std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<x path="Null"><c path="Array"><d/></c></x>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>`PosInfos` is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	`(..., ?pos:haxe.PosInfos)`, each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<class path="haxe.Timer" params="" file="/usr/local/lib/haxe/std/haxe/Timer.hx">
		<event><c path="haxe.MainEvent"/></event>
		<stop public="1" set="method" line="90">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Stops `this` Timer.

		After calling this method, no additional invocations of `this.run`
		will occur.

		It is not possible to restart `this` Timer once stopped.</haxe_doc>
		</stop>
		<run public="1" set="dynamic" line="128">
			<f a=""><x path="Void"/></f>
			<haxe_doc>This method is invoked repeatedly on `this` Timer.

		It can be overridden in a subclass, or rebound directly to a custom
		function:

		```haxe
		var timer = new haxe.Timer(1000); // 1000ms delay
		timer.run = function() { ... }
		```
		
		Once bound, it can still be rebound to different functions until `this`
		Timer is stopped through a call to `this.stop`.</haxe_doc>
		</run>
		<new public="1" set="method" line="60">
			<f a="time_ms">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new timer that will run every `time_ms` milliseconds.

		After creating the Timer instance, it calls `this.run` repeatedly,
		with delays of `time_ms` milliseconds, until `this.stop` is called.

		The first invocation occurs after `time_ms` milliseconds, not
		immediately.

		The accuracy of this may be platform-dependent.</haxe_doc>
		</new>
		<haxe_doc>The `Timer` class allows you to create asynchronous timers on platforms that
	support events.

	The intended usage is to create an instance of the `Timer` class with a given
	interval, set its `run()` method to a custom function to be invoked and
	eventually call `stop()` to stop the `Timer`.

	Note that a running `Timer` may or may not prevent the program to exit
	automatically when `main()` returns.

	It is also possible to extend this class and override its `run()` method in
	the child class.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.Bytes" params="" file="/usr/local/lib/haxe/std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="549" static="1">
			<f a="length">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a new `Bytes` instance with the given `length`. The values of the
		bytes are not initialized and may not be zero.</haxe_doc>
		</alloc>
		<ofString public="1" set="method" line="580" static="1">
			<f a="s:?encoding">
				<c path="String"/>
				<e path="haxe.io.Encoding"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the `Bytes` representation of the given `String`, using the
		specified encoding (UTF-8 by default).</haxe_doc>
		</ofString>
		<ofData public="1" set="method" line="656" static="1">
			<f a="b">
				<t path="haxe.io.BytesData"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the `Bytes` representation of the given `BytesData`.</haxe_doc>
		</ofData>
		<length public="1" set="null"><x path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<blit public="1" set="method" line="90">
			<f a="pos:src:srcpos:len">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Copies `len` bytes from `src` into this instance.
		@param pos Zero-based location in `this` instance at which to start writing
			bytes.
		@param src Source `Bytes` instance from which to copy bytes.
		@param srcpos Zero-based location at `src` from which bytes will be copied.
		@param len Number of bytes to be copied.</haxe_doc>
		</blit>
		<sub public="1" set="method" line="155">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a new `Bytes` instance that contains a copy of `len` bytes of
		`this` instance, starting at index `pos`.</haxe_doc>
		</sub>
		<toString public="1" set="method" line="502">
			<f a=""><c path="String"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a `String` representation of the bytes interpreted as UTF-8.</haxe_doc>
		</toString>
		<toHex public="1" set="method" line="524">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a hexadecimal `String` representation of the bytes of `this`
		instance.</haxe_doc>
		</toHex>
		<new set="method" line="34"><f a="length:b">
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="haxe.crypto.HashMethod" params="" file="/usr/local/lib/haxe/std/haxe/crypto/Hmac.hx" module="haxe.crypto.Hmac">
		<MD5/>
		<SHA1/>
		<SHA256/>
		<haxe_doc>Hash methods for Hmac calculation.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="haxe.crypto.Hmac" params="" file="/usr/local/lib/haxe/std/haxe/crypto/Hmac.hx">
		<method><e path="haxe.crypto.HashMethod"/></method>
		<blockSize><x path="Int"/></blockSize>
		<length><x path="Int"/></length>
		<nullPad set="method" line="62"><f a="s:chunkLen">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></nullPad>
		<make public="1" set="method" line="73"><f a="key:msg">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></make>
		<new public="1" set="method" line="42"><f a="hashMethod">
	<e path="haxe.crypto.HashMethod"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Calculates a Hmac of the given Bytes using a HashMethod.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.crypto.Md5" params="" file="/usr/local/lib/haxe/std/haxe/crypto/Md5.hx">
		<make public="1" set="method" line="39" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></make>
		<make_md5 expr="neko.Lib.load(&quot;std&quot;, &quot;make_md5&quot;, 1)" line="58" static="1">
			<f a="">
				<t path="haxe.io.BytesData"/>
				<t path="haxe.io.BytesData"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "make_md5", 1)</e></m></meta>
		</make_md5>
		<haxe_doc>Creates a MD5 of a String.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.crypto.Sha1" params="" file="/usr/local/lib/haxe/std/haxe/crypto/Sha1.hx">
		<make public="1" set="method" line="35" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></make>
		<bytes2blks set="method" line="115" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="Array"><x path="Int"/></c>
</f></bytes2blks>
		<doEncode set="method" line="50"><f a="x">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
</f></doEncode>
		<ft set="method" line="142">
			<f a="t:b:c:d">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Perform the appropriate triplet combination function for the current iteration</haxe_doc>
		</ft>
		<kt set="method" line="155">
			<f a="t">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Determine the appropriate additive constant for the current iteration</haxe_doc>
		</kt>
		<new set="method" line="48"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Creates a Sha1 of a String.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.crypto.Sha256" params="" file="/usr/local/lib/haxe/std/haxe/crypto/Sha256.hx">
		<make public="1" set="method" line="35" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></make>
		<bytes2blks set="method" line="133" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="Array"><x path="Int"/></c>
</f></bytes2blks>
		<doEncode set="method" line="50"><f a="m:l">
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></doEncode>
		<new public="1" set="method" line="48"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Creates a Sha256 of a String.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.BalancedTree" params="K:V" file="/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx">
		<implements path="haxe.IMap">
			<c path="haxe.ds.BalancedTree.K"/>
			<c path="haxe.ds.BalancedTree.V"/>
		</implements>
		<root><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
</c></root>
		<set public="1" set="method" line="50">
			<f a="key:value">
				<c path="haxe.ds.BalancedTree.K"/>
				<c path="haxe.ds.BalancedTree.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Binds `key` to `value`.

		If `key` is already bound to a value, that binding disappears.

		If `key` is null, the result is unspecified.</haxe_doc>
		</set>
		<get public="1" set="method" line="61">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<x path="Null"><c path="haxe.ds.BalancedTree.V"/></x>
			</f>
			<haxe_doc>Returns the value `key` is bound to.

		If `key` is not bound to any value, `null` is returned.

		If `key` is null, the result is unspecified.</haxe_doc>
		</get>
		<setLoop set="method" line="150"><f a="k:v:node">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></setLoop>
		<balance set="method" line="205"><f a="l:k:v:r">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></balance>
		<compare set="method" line="225"><f a="k1:k2">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.K"/>
	<x path="Int"/>
</f></compare>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new BalancedTree, which is initially empty.</haxe_doc>
		</new>
		<haxe_doc>BalancedTree allows key-value mapping with arbitrary keys, as long as they
	can be ordered. By default, `Reflect.compare` is used in the `compare`
	method, which can be overridden in subclasses.

	Operations have a logarithmic average and worst-case cost.

	Iteration over keys and values, using `keys` and `iterator` respectively,
	are in-order.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.ds.TreeNode" params="K:V" file="/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx" module="haxe.ds.BalancedTree">
		<left public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></left>
		<right public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></right>
		<key public="1"><c path="haxe.ds.TreeNode.K"/></key>
		<value public="1"><c path="haxe.ds.TreeNode.V"/></value>
		<_height><x path="Int"/></_height>
		<new public="1" set="method" line="255">
			<f a="l:k:v:r:?h" v="::::-1">
				<c path="haxe.ds.TreeNode">
					<c path="haxe.ds.TreeNode.K"/>
					<c path="haxe.ds.TreeNode.V"/>
				</c>
				<c path="haxe.ds.TreeNode.K"/>
				<c path="haxe.ds.TreeNode.V"/>
				<c path="haxe.ds.TreeNode">
					<c path="haxe.ds.TreeNode.K"/>
					<c path="haxe.ds.TreeNode.V"/>
				</c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ h : -1 }</e></m></meta>
		</new>
		<haxe_doc>A tree node of `haxe.ds.BalancedTree`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.EnumValueMap" params="K:V" file="/usr/local/lib/haxe/std/haxe/ds/EnumValueMap.hx">
		<extends path="haxe.ds.BalancedTree">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</extends>
		<implements path="haxe.IMap">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</implements>
		<compare set="method" line="32" override="1"><f a="k1:k2">
	<x path="EnumValue"/>
	<x path="EnumValue"/>
	<x path="Int"/>
</f></compare>
		<compareArgs set="method" line="43"><f a="a1:a2">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<x path="Int"/>
</f></compareArgs>
		<compareArg set="method" line="55"><f a="v1:v2">
	<d/>
	<d/>
	<x path="Int"/>
</f></compareArg>
		<new public="1" set="method" line="31"><f a=""><x path="Void"/></f></new>
		<haxe_doc>EnumValueMap allows mapping of enum value keys to arbitrary values.

	Keys are compared by value and recursively over their parameters. If any
	parameter is not an enum value, `Reflect.compare` is used to compare them.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.GenericCell" params="T" file="/usr/local/lib/haxe/std/haxe/ds/GenericStack.hx" module="haxe.ds.GenericStack">
		<elt public="1"><c path="haxe.ds.GenericCell.T"/></elt>
		<next public="1"><c path="haxe.ds.GenericCell"><c path="haxe.ds.GenericCell.T"/></c></next>
		<new public="1" set="method" line="37"><f a="elt:next">
	<c path="haxe.ds.GenericCell.T"/>
	<c path="haxe.ds.GenericCell"><c path="haxe.ds.GenericCell.T"/></c>
	<x path="Void"/>
</f></new>
		<haxe_doc>A cell of `haxe.ds.GenericStack`.

	@see https://haxe.org/manual/std-GenericStack.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.GenericStack" params="T" file="/usr/local/lib/haxe/std/haxe/ds/GenericStack.hx">
		<head public="1"><c path="haxe.ds.GenericCell"><c path="haxe.ds.GenericStack.T"/></c></head>
		<new public="1" set="method" line="107">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty GenericStack.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[A stack of elements.

	This class is generic, which means one type is generated for each type
	parameter T on static targets. For example:

	- `new GenericStack<Int>()` generates `GenericStack_Int`
	- `new GenericStack<String>()` generates `GenericStack_String`

	The generated name is an implementation detail and should not be relied
	upon.

	@see https://haxe.org/manual/std-GenericStack.html]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.ds.HashMap" params="K:V" file="/usr/local/lib/haxe/std/haxe/ds/HashMap.hx">
		<this><c path="haxe.ds._HashMap.HashMapData">
	<c path="haxe.ds.HashMap.K"/>
	<c path="haxe.ds.HashMap.V"/>
</c></this>
		<haxe_doc>HashMap allows mapping of hashable objects to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.IntMap" params="T" file="/usr/local/lib/haxe/std/neko/_std/haxe/ds/IntMap.hx">
		<implements path="haxe.IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<h><d/></h>
		<set public="1" get="inline" set="null" line="32">
			<f a="key:value">
				<x path="Int"/>
				<c path="haxe.ds.IntMap.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method" line="36">
			<f a="key">
				<x path="Int"/>
				<x path="Null"><c path="haxe.ds.IntMap.T"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<new public="1" set="method" line="28">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a new IntMap.</haxe_doc>
		</new>
		<haxe_doc>IntMap allows mapping of Int keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds.List" params="T" file="/usr/local/lib/haxe/std/haxe/ds/List.hx">
		<h><c path="haxe.ds._List.ListNode"><c path="haxe.ds.List.T"/></c></h>
		<q><c path="haxe.ds._List.ListNode"><c path="haxe.ds.List.T"/></c></q>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` List.</haxe_doc>
		</length>
		<push public="1" set="method" line="68">
			<f a="item">
				<c path="haxe.ds.List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the beginning of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<new public="1" set="method" line="44">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of element container objects
	that are chained together. It is optimized so that adding or removing an
	element does not imply copying the whole list content every time.

	@see https://haxe.org/manual/std-List.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="neko.NativeArray" params="T" file="/usr/local/lib/haxe/std/neko/NativeArray.hx"><meta><m n=":keep"/></meta></class>
	<class path="haxe.ds._List.ListNode" params="T" file="/usr/local/lib/haxe/std/haxe/ds/List.hx" private="1" module="haxe.ds.List" extern="1">
		<extends path="neko.NativeArray"><d/></extends>
		<create public="1" params="T" get="inline" set="null" line="257" static="1">
			<f a="item:next">
				<c path="create.T"/>
				<c path="haxe.ds._List.ListNode"><c path="create.T"/></c>
				<c path="haxe.ds._List.ListNode"><c path="create.T"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</create>
		<item public="1" get="accessor" set="accessor"><c path="haxe.ds._List.ListNode.T"/></item>
		<next public="1" get="accessor" set="accessor"><c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListNode.T"/></c></next>
		<get_item get="inline" set="null" line="249"><f a=""><c path="haxe.ds._List.ListNode.T"/></f></get_item>
		<set_item get="inline" set="null" line="251"><f a="v">
	<c path="haxe.ds._List.ListNode.T"/>
	<c path="haxe.ds._List.ListNode.T"/>
</f></set_item>
		<get_next get="inline" set="null" line="253"><f a=""><c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListNode.T"/></c></f></get_next>
		<set_next get="inline" set="null" line="255"><f a="v">
	<c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListNode.T"/></c>
	<c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListNode.T"/></c>
</f></set_next>
	</class>
	<class path="haxe.ds._List.ListIterator" params="T" file="/usr/local/lib/haxe/std/haxe/ds/List.hx" private="1" module="haxe.ds.List">
		<head><c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListIterator.T"/></c></head>
		<hasNext public="1" get="inline" set="null" line="284"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="288"><f a=""><c path="haxe.ds._List.ListIterator.T"/></f></next>
		<new public="1" get="inline" set="null" line="280"><f a="head">
	<c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListIterator.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.ds.Map" params="K:V" file="/usr/local/lib/haxe/std/haxe/ds/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><c path="haxe.IMap">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</c></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="toEnumValueMapMap.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="toObjectMap.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `[key1 => value1, key2 => value2]` syntax.

	Map is an abstract type, it is not available at runtime.

	@see https://haxe.org/manual/std-Map.html]]></haxe_doc>
		<meta><m n=":multiType"><e>@:followWithAbstracts K</e></m></meta>
		<impl><class path="haxe.ds._Map.Map_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/ds/Map.hx" private="1" module="haxe.ds.Map"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.ObjectMap" params="K:V" file="/usr/local/lib/haxe/std/neko/_std/haxe/ds/ObjectMap.hx">
		<implements path="haxe.IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<count expr="0" line="27" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</count>
		<h><a/></h>
		<k><a/></k>
		<set public="1" get="inline" set="null" line="47">
			<f a="key:value">
				<c path="haxe.ds.ObjectMap.K"/>
				<c path="haxe.ds.ObjectMap.V"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method" line="54">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Null"><c path="haxe.ds.ObjectMap.V"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<new public="1" set="method" line="42">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a new ObjectMap.</haxe_doc>
		</new>
		<haxe_doc>ObjectMap allows mapping of object keys to arbitrary values.

	On static targets, the keys are considered to be strong references. Refer
	to `haxe.ds.WeakMap` for a weak reference version.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="haxe.ds.ReadOnlyArray" params="T" file="/usr/local/lib/haxe/std/haxe/ds/ReadOnlyArray.hx">
		<from><icast><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></icast></from>
		<this><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></this>
		<haxe_doc>`ReadOnlyArray` is an abstract over an ordinary `Array` which only exposes
	APIs that don't modify the instance, hence "read-only".

	Note that this doesn't necessarily mean that the instance is *immutable*.
	Other code holding a reference to the underlying `Array` can still modify it,
	and the reference can be obtained with a `cast`.</haxe_doc>
		<meta><m n=":forward">
	<e>concat</e>
	<e>copy</e>
	<e>filter</e>
	<e>indexOf</e>
	<e>iterator</e>
	<e>join</e>
	<e>lastIndexOf</e>
	<e>map</e>
	<e>slice</e>
	<e>toString</e>
</m></meta>
		<impl><class path="haxe.ds._ReadOnlyArray.ReadOnlyArray_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/ds/ReadOnlyArray.hx" private="1" module="haxe.ds.ReadOnlyArray">
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The length of `this` Array.</haxe_doc>
	</length>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="haxe.ds.StringMap" params="T" file="/usr/local/lib/haxe/std/neko/_std/haxe/ds/StringMap.hx">
		<implements path="haxe.IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<h><d/></h>
		<set public="1" get="inline" set="null" line="32">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" get="inline" set="null" line="36">
			<f a="key">
				<c path="String"/>
				<x path="Null"><c path="haxe.ds.StringMap.T"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<keys public="1" set="method" line="48">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<new public="1" set="method" line="28">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<typedef path="haxe.ds._Vector.VectorData" params="T" file="/usr/local/lib/haxe/std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector"><c path="neko.NativeArray"><c path="haxe.ds._Vector.VectorData.T"/></c></typedef>
	<abstract path="haxe.ds.Vector" params="T" file="/usr/local/lib/haxe/std/haxe/ds/Vector.hx">
		<this><t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t></this>
		<haxe_doc>A Vector is a storage of fixed size. It can be faster than Array on some
	targets, and is never slower.

	@see https://haxe.org/manual/std-vector.html</haxe_doc>
		<impl><class path="haxe.ds._Vector.Vector_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector">
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns the length of `this` Vector.</haxe_doc>
	</length>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<typedef path="haxe.http._HttpBase.StringKeyValue" params="" file="/usr/local/lib/haxe/std/haxe/http/HttpBase.hx" private="1" module="haxe.http.HttpBase"><a>
	<value><c path="String"/></value>
	<name><c path="String"/></name>
</a></typedef>
	<class path="haxe.http.HttpBase" params="" file="/usr/local/lib/haxe/std/haxe/http/HttpBase.hx">
		<url public="1">
			<c path="String"/>
			<haxe_doc>The url of `this` request. It is used only by the `request()` method and
		can be changed in order to send the same request to different target
		Urls.</haxe_doc>
		</url>
		<responseData public="1" get="accessor" set="null"><x path="Null"><c path="String"/></x></responseData>
		<responseBytes public="1" set="null"><x path="Null"><c path="haxe.io.Bytes"/></x></responseBytes>
		<responseAsString><x path="Null"><c path="String"/></x></responseAsString>
		<postData><x path="Null"><c path="String"/></x></postData>
		<postBytes><x path="Null"><c path="haxe.io.Bytes"/></x></postBytes>
		<headers><c path="Array"><t path="haxe.http._HttpBase.StringKeyValue"/></c></headers>
		<params><c path="Array"><t path="haxe.http._HttpBase.StringKeyValue"/></c></params>
		<emptyOnData final="1"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></emptyOnData>
		<onData public="1" set="dynamic" line="196">
			<f a="data">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This method is called upon a successful request, with `data` containing
		the result String.

		The intended usage is to bind it to a custom function:
		`httpInstance.onData = function(data) { // handle result }`</haxe_doc>
		</onData>
		<onBytes public="1" set="dynamic" line="205">
			<f a="data">
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This method is called upon a successful request, with `data` containing
		the result String.

		The intended usage is to bind it to a custom function:
		`httpInstance.onBytes = function(data) { // handle result }`</haxe_doc>
		</onBytes>
		<onError public="1" set="dynamic" line="214">
			<f a="msg">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This method is called upon a request error, with `msg` containing the
		error description.

		The intended usage is to bind it to a custom function:
		`httpInstance.onError = function(msg) { // handle error }`</haxe_doc>
		</onError>
		<onStatus public="1" set="dynamic" line="223">
			<f a="status">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This method is called upon a Http status change, with `status` being the
		new status.

		The intended usage is to bind it to a custom function:
		`httpInstance.onStatus = function(status) { // handle status }`</haxe_doc>
		</onStatus>
		<hasOnData set="method" line="228">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Override this if extending `haxe.Http` with overriding `onData`</haxe_doc>
		</hasOnData>
		<success set="method" line="232"><f a="data">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></success>
		<get_responseData set="method" line="240"><f a=""><x path="Null"><c path="String"/></x></f></get_responseData>
		<new public="1" set="method" line="71">
			<f a="url">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Http instance with `url` as parameter.

		This does not do a request until `request()` is called.

		If `url` is null, the field url must be set to a value before making the
		call to `request()`, or the result is unspecified.

		(Php) Https (SSL) connections are allowed only if the OpenSSL extension
		is enabled.</haxe_doc>
		</new>
		<haxe_doc>This class can be used to handle Http requests consistently across
	platforms. There are two intended usages:

	- call `haxe.Http.requestUrl(url)` and receive the result as a `String`
	(not available on flash)
	- create a `new haxe.Http(url)`, register your callbacks for `onData`,
	`onError` and `onStatus`, then call `request()`.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.BytesBuffer" params="" file="/usr/local/lib/haxe/std/haxe/io/BytesBuffer.hx">
		<b><d/></b>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the buffer in bytes.</haxe_doc>
		</length>
		<getBytes public="1" set="method" line="201">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns either a copy or a reference of the current bytes.
		Once called, the buffer should no longer be used.</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="45">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="/usr/local/lib/haxe/std/haxe/io/BytesData.hx"><c path="neko.NativeString"/></typedef>
	<class path="haxe.io.Input" params="" file="/usr/local/lib/haxe/std/haxe/io/Input.hx">
		<readByte public="1" set="method" line="49">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read and return one byte.</haxe_doc>
		</readByte>
		<readBytes public="1" set="method" line="64">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Read `len` bytes and write them into `s` to the position specified by `pos`.

		Returns the actual length of read data that can be smaller than `len`.

		See `readFullBytes` that tries to read the exact amount of specified bytes.</haxe_doc>
		</readBytes>
		<close public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Close the input source.

		Behaviour while reading after calling this method is unspecified.</haxe_doc>
		</close>
		<readFullBytes public="1" set="method" line="132">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Read `len` bytes and write them into `s` to the position specified by `pos`.

		Unlike `readBytes`, this method tries to read the exact `len` amount of bytes.</haxe_doc>
		</readFullBytes>
		<read public="1" set="method" line="145">
			<f a="nbytes">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Read and return `nbytes` bytes.</haxe_doc>
		</read>
		<readLine public="1" set="method" line="176">
			<f a=""><c path="String"/></f>
			<haxe_doc>Read a line of text separated by CR and/or LF bytes.

		The CR/LF characters are not included in the resulting string.</haxe_doc>
		</readLine>
		<readString public="1" set="method" line="304">
			<f a="len:?encoding">
				<x path="Int"/>
				<e path="haxe.io.Encoding"/>
				<c path="String"/>
			</f>
			<haxe_doc>Read and `len` bytes as a string.</haxe_doc>
		</readString>
		<haxe_doc>An Input is an abstract reader. See other classes in the `haxe.io` package
	for several possible implementations.

	All functions which read data throw `Eof` when the end of the stream
	is reached.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.BytesInput" params="" file="/usr/local/lib/haxe/std/haxe/io/BytesInput.hx">
		<extends path="haxe.io.Input"/>
		<b><t path="haxe.io.BytesData"/></b>
		<pos><x path="Int"/></pos>
		<len><x path="Int"/></len>
		<totlen><x path="Int"/></totlen>
		<position public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The current position in the stream in bytes.</haxe_doc>
		</position>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the stream in bytes.</haxe_doc>
		</length>
		<readByte public="1" set="method" line="96" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
		</readByte>
		<readBytes public="1" set="method" line="119" override="1">
			<f a="buf:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</readBytes>
		<new public="1" set="method" line="39"><f a="b:?pos:?len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.Output" params="" file="/usr/local/lib/haxe/std/haxe/io/Output.hx">
		<writeByte public="1" set="method" line="46">
			<f a="c">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write one byte.</haxe_doc>
		</writeByte>
		<writeBytes public="1" set="method" line="57">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Write `len` bytes from `s` starting by position specified by `pos`.

		Returns the actual length of written data that can differ from `len`.

		See `writeFullBytes` that tries to write the exact amount of specified bytes.</haxe_doc>
		</writeBytes>
		<flush public="1" set="method" line="85">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Flush any buffered data.</haxe_doc>
		</flush>
		<close public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Close the output.

		Behaviour while writing after calling this method is unspecified.</haxe_doc>
		</close>
		<writeFullBytes public="1" set="method" line="120">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `len` bytes from `s` starting by position specified by `pos`.

		Unlike `writeBytes`, this method tries to write the exact `len` amount of bytes.</haxe_doc>
		</writeFullBytes>
		<prepare public="1" set="method" line="246">
			<f a="nbytes">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inform that we are about to write at least `nbytes` bytes.

		The underlying implementation can allocate proper working space depending
		on this information, or simply ignore it. This is not a mandatory call
		but a tip and is only used in some specific cases.</haxe_doc>
		</prepare>
		<writeString public="1" set="method" line="278">
			<f a="s:?encoding">
				<c path="String"/>
				<e path="haxe.io.Encoding"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Write `s` string.</haxe_doc>
		</writeString>
		<haxe_doc>An Output is an abstract write. A specific output implementation will only
	have to override the `writeByte` and maybe the `write`, `flush` and `close`
	methods. See `File.write` and `String.write` for two ways of creating an
	Output.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.BytesOutput" params="" file="/usr/local/lib/haxe/std/haxe/io/BytesOutput.hx">
		<extends path="haxe.io.Output"/>
		<b><c path="haxe.io.BytesBuffer"/></b>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the stream in bytes.</haxe_doc>
		</length>
		<writeByte public="1" set="method" line="51" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="59" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<getBytes public="1" set="method" line="137">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>Returns the `Bytes` of this output.

		This function should not be called more than once on a given
		`BytesOutput` instance.</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="35"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="haxe.io.Encoding" params="" file="/usr/local/lib/haxe/std/haxe/io/Encoding.hx">
		<UTF8/>
		<RawNative><haxe_doc>Output the string the way the platform represent it in memory. This is the most efficient but is platform-specific</haxe_doc></RawNative>
		<haxe_doc>String binary encoding supported by Haxe I/O</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="haxe.io.Eof" params="" file="/usr/local/lib/haxe/std/haxe/io/Eof.hx">
		<toString set="method" line="32">
			<f a=""><c path="String"/></f>
			<meta><m n=":ifFeature"><e>"haxe.io.Eof.*"</e></m></meta>
		</toString>
		<new public="1" set="method" line="29"><f a=""><x path="Void"/></f></new>
		<haxe_doc>This exception is raised when reading while data is no longer available in the `haxe.io.Input`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="haxe.io.Error" params="" file="/usr/local/lib/haxe/std/haxe/io/Error.hx">
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="haxe.io.Path" params="" file="/usr/local/lib/haxe/std/haxe/io/Path.hx">
		<withoutExtension public="1" set="method" line="123" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String representation of `path` without the file extension.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</withoutExtension>
		<addTrailingSlash public="1" set="method" line="271" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Adds a trailing slash to `path`, if it does not have one already.

		If the last slash in `path` is a backslash, a backslash is appended to
		`path`.

		If the last slash in `path` is a slash, or if no slash is found, a slash
		is appended to `path`. In particular, this applies to the empty String
		`""`.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</addTrailingSlash>
		<removeTrailingSlashes public="1" set="method" line="299" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes trailing slashes from `path`.

		If `path` does not end with a `/` or `\`, `path` is returned unchanged.

		Otherwise the substring of `path` excluding the trailing slashes or
		backslashes is returned.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</removeTrailingSlashes>
		<dir public="1">
			<x path="Null"><c path="String"/></x>
			<haxe_doc>The directory.

		This is the leading part of the path that is not part of the file name
		and the extension.

		Does not end with a `/` or `\` separator.

		If the path has no directory, the value is `null`.</haxe_doc>
		</dir>
		<file public="1">
			<c path="String"/>
			<haxe_doc>The file name.

		This is the part of the part between the directory and the extension.

		If there is no file name, e.g. for `".htaccess"` or `"/dir/"`, the value
		is the empty String `""`.</haxe_doc>
		</file>
		<ext public="1">
			<x path="Null"><c path="String"/></x>
			<haxe_doc>The file extension.

		It is separated from the file name by a dot. This dot is not part of
		the extension.

		If the path has no extension, the value is `null`.</haxe_doc>
		</ext>
		<backslash public="1">
			<x path="Bool"/>
			<haxe_doc>`true` if the last directory separator is a backslash, `false` otherwise.</haxe_doc>
		</backslash>
		<toString public="1" set="method" line="114">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String representation of `this` path.

		If `this.backslash` is `true`, backslash is used as directory separator,
		otherwise slash is used. This only affects the separator between
		`this.dir` and `this.file`.

		If `this.directory` or `this.extension` is `null`, their representation
		is the empty String `""`.</haxe_doc>
		</toString>
		<new public="1" set="method" line="76">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new `Path` instance by parsing `path`.

		Path information can be retrieved by accessing the `dir`, `file` and `ext`
		properties.</haxe_doc>
		</new>
		<haxe_doc>This class provides a convenient way of working with paths. It supports the
	common path formats:

	- `directory1/directory2/filename.extension`
	- `directory1\directory2\filename.extension`</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.StringInput" params="" file="/usr/local/lib/haxe/std/haxe/io/StringInput.hx">
		<extends path="haxe.io.BytesInput"/>
		<new public="1" set="method" line="26"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="haxe.zip.FlushMode" params="" file="/usr/local/lib/haxe/std/haxe/zip/FlushMode.hx">
		<NO/>
		<SYNC/>
		<FULL/>
		<FINISH/>
		<BLOCK/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="haxe.zip.Uncompress" params="" file="/usr/local/lib/haxe/std/neko/_std/haxe/zip/Uncompress.hx">
		<run public="1" set="method" line="45" static="1"><f a="src:?bufsize">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<_inflate_init expr="neko.Lib.load(&quot;zlib&quot;, &quot;inflate_init&quot;, 1)" line="64" static="1">
			<f a="">
				<x path="Null"><x path="Int"/></x>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("zlib", "inflate_init", 1)</e></m></meta>
		</_inflate_init>
		<_inflate_buffer expr="neko.Lib.load(&quot;zlib&quot;, &quot;inflate_buffer&quot;, 5)" line="65" static="1">
			<f a="::::">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<a>
					<write><x path="Int"/></write>
					<read><x path="Int"/></read>
					<done><x path="Bool"/></done>
				</a>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("zlib", "inflate_buffer", 5)</e></m></meta>
		</_inflate_buffer>
		<_inflate_end expr="neko.Lib.load(&quot;zlib&quot;, &quot;inflate_end&quot;, 1)" line="66" static="1">
			<f a="">
				<d/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("zlib", "inflate_end", 1)</e></m></meta>
		</_inflate_end>
		<_set_flush_mode expr="neko.Lib.load(&quot;zlib&quot;, &quot;set_flush_mode&quot;, 2)" line="67" static="1">
			<f a=":">
				<d/>
				<unknown/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("zlib", "set_flush_mode", 2)</e></m></meta>
		</_set_flush_mode>
		<s><d/></s>
		<execute public="1" set="method" line="33"><f a="src:srcPos:dst:dstPos">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<a>
		<write><x path="Int"/></write>
		<read><x path="Int"/></read>
		<done><x path="Bool"/></done>
	</a>
</f></execute>
		<setFlushMode public="1" set="method" line="37">
			<f a="f">
				<e path="haxe.zip.FlushMode"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setFlushMode>
		<close public="1" set="method" line="41"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="29"><f a="?windowBits">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<enum path="hscript.Const" params="" file="/usr/local/lib/haxe/lib/hscript/2,3,0/hscript/Expr.hx" module="hscript.Expr">
		<CInt a="v"><x path="Int"/></CInt>
		<CFloat a="f"><x path="Float"/></CFloat>
		<CString a="s"><c path="String"/></CString>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="hscript.ExprDef" params="" file="/usr/local/lib/haxe/lib/hscript/2,3,0/hscript/Expr.hx" module="hscript.Expr"><e path="hscript.Expr"/></typedef>
	<enum path="hscript.Expr" params="" file="/usr/local/lib/haxe/lib/hscript/2,3,0/hscript/Expr.hx">
		<EConst a="c"><e path="hscript.Const"/></EConst>
		<EIdent a="v"><c path="String"/></EIdent>
		<EVar a="n:?t:?e">
			<c path="String"/>
			<e path="hscript.CType"/>
			<e path="hscript.Expr"/>
		</EVar>
		<EParent a="e"><e path="hscript.Expr"/></EParent>
		<EBlock a="e"><c path="Array"><e path="hscript.Expr"/></c></EBlock>
		<EField a="e:f">
			<e path="hscript.Expr"/>
			<c path="String"/>
		</EField>
		<EBinop a="op:e1:e2">
			<c path="String"/>
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
		</EBinop>
		<EUnop a="op:prefix:e">
			<c path="String"/>
			<x path="Bool"/>
			<e path="hscript.Expr"/>
		</EUnop>
		<ECall a="e:params">
			<e path="hscript.Expr"/>
			<c path="Array"><e path="hscript.Expr"/></c>
		</ECall>
		<EIf a="cond:e1:?e2">
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
		</EIf>
		<EWhile a="cond:e">
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
		</EWhile>
		<EFor a="v:it:e">
			<c path="String"/>
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
		</EFor>
		<EBreak/>
		<EContinue/>
		<EFunction a="args:e:?name:?ret">
			<c path="Array"><t path="hscript.Argument"/></c>
			<e path="hscript.Expr"/>
			<c path="String"/>
			<e path="hscript.CType"/>
		</EFunction>
		<EReturn a="?e"><e path="hscript.Expr"/></EReturn>
		<EArray a="e:index">
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
		</EArray>
		<EArrayDecl a="e"><c path="Array"><e path="hscript.Expr"/></c></EArrayDecl>
		<ENew a="cl:params">
			<c path="String"/>
			<c path="Array"><e path="hscript.Expr"/></c>
		</ENew>
		<EThrow a="e"><e path="hscript.Expr"/></EThrow>
		<ETry a="e:v:t:ecatch">
			<e path="hscript.Expr"/>
			<c path="String"/>
			<x path="Null"><e path="hscript.CType"/></x>
			<e path="hscript.Expr"/>
		</ETry>
		<EObject a="fl"><c path="Array"><a>
	<name><c path="String"/></name>
	<e><e path="hscript.Expr"/></e>
</a></c></EObject>
		<ETernary a="cond:e1:e2">
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
		</ETernary>
		<ESwitch a="e:cases:?defaultExpr">
			<e path="hscript.Expr"/>
			<c path="Array"><a>
	<values><c path="Array"><e path="hscript.Expr"/></c></values>
	<expr><e path="hscript.Expr"/></expr>
</a></c>
			<e path="hscript.Expr"/>
		</ESwitch>
		<EDoWhile a="cond:e">
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
		</EDoWhile>
		<EMeta a="name:args:e">
			<c path="String"/>
			<c path="Array"><e path="hscript.Expr"/></c>
			<e path="hscript.Expr"/>
		</EMeta>
		<ECheckType a="e:t">
			<e path="hscript.Expr"/>
			<e path="hscript.CType"/>
		</ECheckType>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="hscript.Argument" params="" file="/usr/local/lib/haxe/lib/hscript/2,3,0/hscript/Expr.hx" module="hscript.Expr"><a>
	<value>
		<x path="Null"><e path="hscript.Expr"/></x>
		<meta><m n=":optional"/></meta>
	</value>
	<t>
		<x path="Null"><e path="hscript.CType"/></x>
		<meta><m n=":optional"/></meta>
	</t>
	<opt>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</opt>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="hscript.Metadata" params="" file="/usr/local/lib/haxe/lib/hscript/2,3,0/hscript/Expr.hx" module="hscript.Expr"><c path="Array"><a>
	<params><c path="Array"><e path="hscript.Expr"/></c></params>
	<name><c path="String"/></name>
</a></c></typedef>
	<enum path="hscript.CType" params="" file="/usr/local/lib/haxe/lib/hscript/2,3,0/hscript/Expr.hx" module="hscript.Expr">
		<CTPath a="path:?params">
			<c path="Array"><c path="String"/></c>
			<c path="Array"><e path="hscript.CType"/></c>
		</CTPath>
		<CTFun a="args:ret">
			<c path="Array"><e path="hscript.CType"/></c>
			<e path="hscript.CType"/>
		</CTFun>
		<CTAnon a="fields"><c path="Array"><a>
	<t><e path="hscript.CType"/></t>
	<name><c path="String"/></name>
	<meta>
		<x path="Null"><t path="hscript.Metadata"/></x>
		<meta><m n=":optional"/></meta>
	</meta>
</a></c></CTAnon>
		<CTParent a="t"><e path="hscript.CType"/></CTParent>
		<CTOpt a="t"><e path="hscript.CType"/></CTOpt>
		<CTNamed a="n:t">
			<c path="String"/>
			<e path="hscript.CType"/>
		</CTNamed>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="hscript.Error" params="" file="/usr/local/lib/haxe/lib/hscript/2,3,0/hscript/Expr.hx" module="hscript.Expr">
		<EInvalidChar a="c"><x path="Int"/></EInvalidChar>
		<EUnexpected a="s"><c path="String"/></EUnexpected>
		<EUnterminatedString/>
		<EUnterminatedComment/>
		<EInvalidPreprocessor a="msg"><c path="String"/></EInvalidPreprocessor>
		<EUnknownVariable a="v"><c path="String"/></EUnknownVariable>
		<EInvalidIterator a="v"><c path="String"/></EInvalidIterator>
		<EInvalidOp a="op"><c path="String"/></EInvalidOp>
		<EInvalidAccess a="f"><c path="String"/></EInvalidAccess>
		<ECustom a="msg"><c path="String"/></ECustom>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="hscript.ModuleDecl" params="" file="/usr/local/lib/haxe/lib/hscript/2,3,0/hscript/Expr.hx" module="hscript.Expr">
		<DPackage a="path"><c path="Array"><c path="String"/></c></DPackage>
		<DImport a="path:?everything">
			<c path="Array"><c path="String"/></c>
			<x path="Bool"/>
		</DImport>
		<DClass a="c"><t path="hscript.ClassDecl"/></DClass>
		<DTypedef a="c"><t path="hscript.TypeDecl"/></DTypedef>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="hscript.ModuleType" params="" file="/usr/local/lib/haxe/lib/hscript/2,3,0/hscript/Expr.hx" module="hscript.Expr"><a>
	<params><a/></params>
	<name><c path="String"/></name>
	<meta><t path="hscript.Metadata"/></meta>
	<isPrivate><x path="Bool"/></isPrivate>
</a></typedef>
	<typedef path="hscript.ClassDecl" params="" file="/usr/local/lib/haxe/lib/hscript/2,3,0/hscript/Expr.hx" module="hscript.Expr"><a>
	<params><a/></params>
	<name><c path="String"/></name>
	<meta><t path="hscript.Metadata"/></meta>
	<isPrivate><x path="Bool"/></isPrivate>
	<isExtern><x path="Bool"/></isExtern>
	<implement><c path="Array"><e path="hscript.CType"/></c></implement>
	<fields><c path="Array"><t path="hscript.FieldDecl"/></c></fields>
	<extend><x path="Null"><e path="hscript.CType"/></x></extend>
</a></typedef>
	<typedef path="hscript.TypeDecl" params="" file="/usr/local/lib/haxe/lib/hscript/2,3,0/hscript/Expr.hx" module="hscript.Expr"><a>
	<t><e path="hscript.CType"/></t>
	<params><a/></params>
	<name><c path="String"/></name>
	<meta><t path="hscript.Metadata"/></meta>
	<isPrivate><x path="Bool"/></isPrivate>
</a></typedef>
	<typedef path="hscript.FieldDecl" params="" file="/usr/local/lib/haxe/lib/hscript/2,3,0/hscript/Expr.hx" module="hscript.Expr"><a>
	<name><c path="String"/></name>
	<meta><t path="hscript.Metadata"/></meta>
	<kind><e path="hscript.FieldKind"/></kind>
	<access><c path="Array"><e path="hscript.FieldAccess"/></c></access>
</a></typedef>
	<enum path="hscript.FieldAccess" params="" file="/usr/local/lib/haxe/lib/hscript/2,3,0/hscript/Expr.hx" module="hscript.Expr">
		<APublic/>
		<APrivate/>
		<AInline/>
		<AOverride/>
		<AStatic/>
		<AMacro/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="hscript.FieldKind" params="" file="/usr/local/lib/haxe/lib/hscript/2,3,0/hscript/Expr.hx" module="hscript.Expr">
		<KFunction a="f"><t path="hscript.FunctionDecl"/></KFunction>
		<KVar a="v"><t path="hscript.VarDecl"/></KVar>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="hscript.FunctionDecl" params="" file="/usr/local/lib/haxe/lib/hscript/2,3,0/hscript/Expr.hx" module="hscript.Expr"><a>
	<ret><x path="Null"><e path="hscript.CType"/></x></ret>
	<expr><e path="hscript.Expr"/></expr>
	<args><c path="Array"><t path="hscript.Argument"/></c></args>
</a></typedef>
	<typedef path="hscript.VarDecl" params="" file="/usr/local/lib/haxe/lib/hscript/2,3,0/hscript/Expr.hx" module="hscript.Expr"><a>
	<type><x path="Null"><e path="hscript.CType"/></x></type>
	<set><x path="Null"><c path="String"/></x></set>
	<get><x path="Null"><c path="String"/></x></get>
	<expr><x path="Null"><e path="hscript.Expr"/></x></expr>
</a></typedef>
	<enum path="hscript._Interp.Stop" params="" file="/usr/local/lib/haxe/lib/hscript/2,3,0/hscript/Interp.hx" private="1" module="hscript.Interp">
		<SBreak/>
		<SContinue/>
		<SReturn/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="hscript.Token" params="" file="/usr/local/lib/haxe/lib/hscript/2,3,0/hscript/Parser.hx" module="hscript.Parser">
		<TEof/>
		<TConst a="c"><e path="hscript.Const"/></TConst>
		<TId a="s"><c path="String"/></TId>
		<TOp a="s"><c path="String"/></TOp>
		<TPOpen/>
		<TPClose/>
		<TBrOpen/>
		<TBrClose/>
		<TDot/>
		<TComma/>
		<TSemicolon/>
		<TBkOpen/>
		<TBkClose/>
		<TQuestion/>
		<TDoubleDot/>
		<TMeta a="s"><c path="String"/></TMeta>
		<TPrepro a="s"><c path="String"/></TPrepro>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="hscript.Parser" params="" file="/usr/local/lib/haxe/lib/hscript/2,3,0/hscript/Parser.hx">
		<p1 get="inline" set="null" expr="0" line="97" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</p1>
		<readPos get="inline" set="null" expr="0" line="98" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</readPos>
		<tokenMin get="inline" set="null" expr="0" line="99" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</tokenMin>
		<tokenMax get="inline" set="null" expr="0" line="100" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</tokenMax>
		<line public="1"><x path="Int"/></line>
		<opChars public="1"><c path="String"/></opChars>
		<identChars public="1"><c path="String"/></identChars>
		<opPriority public="1"><t path="Map">
	<c path="String"/>
	<x path="Int"/>
</t></opPriority>
		<opRightAssoc public="1"><t path="Map">
	<c path="String"/>
	<x path="Bool"/>
</t></opRightAssoc>
		<unops public="1"><t path="Map">
	<c path="String"/>
	<x path="Bool"/>
</t></unops>
		<preprocesorValues public="1" expr="new Map()">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
			<haxe_doc>allows to check for #if / #else in code</haxe_doc>
		</preprocesorValues>
		<allowJSON public="1">
			<x path="Bool"/>
			<haxe_doc>activate JSON compatiblity</haxe_doc>
		</allowJSON>
		<allowTypes public="1">
			<x path="Bool"/>
			<haxe_doc>allow types declarations</haxe_doc>
		</allowTypes>
		<allowMetadata public="1">
			<x path="Bool"/>
			<haxe_doc>allow haxe metadata declarations</haxe_doc>
		</allowMetadata>
		<input><c path="haxe.io.Input"/></input>
		<char><x path="Int"/></char>
		<ops><c path="Array"><x path="Bool"/></c></ops>
		<idents><c path="Array"><x path="Bool"/></c></idents>
		<uid expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</uid>
		<tokens><c path="haxe.ds.GenericStack"><e path="hscript.Token"/></c></tokens>
		<error public="1" get="inline" set="null" line="144"><f a="err:pmin:pmax">
	<e path="hscript.Error"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></error>
		<invalidChar public="1" set="method" line="152"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></invalidChar>
		<initParser set="method" line="156"><f a="origin">
	<x path="Null"><c path="String"/></x>
	<x path="Void"/>
</f></initParser>
		<parseString public="1" set="method" line="180">
			<f a="s:?origin" v=":&quot;hscript&quot;">
				<c path="String"/>
				<c path="String"/>
				<e path="hscript.Expr"/>
			</f>
			<meta><m n=":value"><e>{ origin : "hscript" }</e></m></meta>
		</parseString>
		<parse public="1" set="method" line="184">
			<f a="s:?origin" v=":&quot;hscript&quot;">
				<c path="haxe.io.Input"/>
				<c path="String"/>
				<e path="hscript.Expr"/>
			</f>
			<meta><m n=":value"><e>{ origin : "hscript" }</e></m></meta>
		</parse>
		<unexpected set="method" line="197"><f a="tk">
	<e path="hscript.Token"/>
	<d/>
</f></unexpected>
		<push get="inline" set="null" line="202"><f a="tk">
	<e path="hscript.Token"/>
	<x path="Void"/>
</f></push>
		<ensure get="inline" set="null" line="212"><f a="tk">
	<x path="Null"><e path="hscript.Token"/></x>
	<x path="Void"/>
</f></ensure>
		<ensureToken get="inline" set="null" line="217"><f a="tk">
	<x path="Null"><e path="hscript.Token"/></x>
	<x path="Void"/>
</f></ensureToken>
		<maybe set="method" line="222"><f a="tk">
	<x path="Null"><e path="hscript.Token"/></x>
	<x path="Bool"/>
</f></maybe>
		<getIdent set="method" line="230"><f a=""><c path="String"/></f></getIdent>
		<expr get="inline" set="null" line="240"><f a="e">
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
</f></expr>
		<pmin get="inline" set="null" line="248"><f a="e">
	<e path="hscript.Expr"/>
	<x path="Int"/>
</f></pmin>
		<pmax get="inline" set="null" line="256"><f a="e">
	<e path="hscript.Expr"/>
	<x path="Int"/>
</f></pmax>
		<mk get="inline" set="null" line="264"><f a="e:?pmin:?pmax">
	<e path="hscript.Expr"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="hscript.Expr"/>
</f></mk>
		<isBlock set="method" line="275"><f a="e">
	<e path="hscript.Expr"/>
	<x path="Bool"/>
</f></isBlock>
		<parseFullExpr set="method" line="293"><f a="exprs">
	<c path="Array"><e path="hscript.Expr"/></c>
	<x path="Void"/>
</f></parseFullExpr>
		<parseObject set="method" line="313"><f a="p1">
	<x path="Null"><x path="Int"/></x>
	<e path="hscript.Expr"/>
</f></parseObject>
		<parseExpr set="method" line="347"><f a=""><e path="hscript.Expr"/></f></parseExpr>
		<parseLambda set="method" line="476"><f a="args:pmin">
	<c path="Array"><t path="hscript.Argument"/></c>
	<x path="Null"><x path="Int"/></x>
	<e path="hscript.Expr"/>
</f></parseLambda>
		<parseMetaArgs set="method" line="495"><f a=""><c path="Array"><e path="hscript.Expr"/></c></f></parseMetaArgs>
		<mapCompr set="method" line="519"><f a="tmp:e">
	<c path="String"/>
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
</f></mapCompr>
		<makeUnop set="method" line="539"><f a="op:e">
	<c path="String"/>
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
</f></makeUnop>
		<makeBinop set="method" line="547"><f a="op:e1:e">
	<c path="String"/>
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
</f></makeBinop>
		<parseStructure set="method" line="564"><f a="id">
	<c path="String"/>
	<e path="hscript.Expr"/>
</f></parseStructure>
		<parseExprNext set="method" line="750"><f a="e1">
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
</f></parseExprNext>
		<parseFunctionArgs set="method" line="797"><f a=""><c path="Array"><t path="hscript.Argument"/></c></f></parseFunctionArgs>
		<parseFunctionDecl set="method" line="837"><f a=""><a>
	<ret><e path="hscript.CType"/></ret>
	<body><e path="hscript.Expr"/></body>
	<args><c path="Array"><t path="hscript.Argument"/></c></args>
</a></f></parseFunctionDecl>
		<parsePath set="method" line="851"><f a=""><c path="Array"><c path="String"/></c></f></parsePath>
		<parseType set="method" line="864"><f a=""><e path="hscript.CType"/></f></parseType>
		<parseTypeNext set="method" line="984"><f a="t">
	<e path="hscript.CType"/>
	<e path="hscript.CType"/>
</f></parseTypeNext>
		<parseExprList set="method" line="1006"><f a="etk">
	<x path="Null"><e path="hscript.Token"/></x>
	<c path="Array"><e path="hscript.Expr"/></c>
</f></parseExprList>
		<parseModule public="1" set="method" line="1027">
			<f a="content:?origin" v=":&quot;hscript&quot;">
				<c path="String"/>
				<c path="String"/>
				<c path="Array"><e path="hscript.ModuleDecl"/></c>
			</f>
			<meta><m n=":value"><e>{ origin : "hscript" }</e></m></meta>
		</parseModule>
		<parseMetadata set="method" line="1042"><f a=""><t path="hscript.Metadata"/></f></parseMetadata>
		<parseParams set="method" line="1057"><f a=""><a/></f></parseParams>
		<parseModuleDecl set="method" line="1063"><f a=""><e path="hscript.ModuleDecl"/></f></parseModuleDecl>
		<parseField set="method" line="1156"><f a=""><t path="hscript.FieldDecl"/></f></parseField>
		<incPos get="inline" set="null" line="1229"><f a=""><x path="Void"/></f></incPos>
		<readChar set="method" line="1235"><f a=""><x path="Int"/></f></readChar>
		<readString set="method" line="1240"><f a="until">
	<x path="Int"/>
	<c path="String"/>
</f></readString>
		<token set="method" line="1318"><f a=""><x path="Null"><e path="hscript.Token"/></x></f></token>
		<preprocValue set="method" line="1548"><f a="id">
	<c path="String"/>
	<d/>
</f></preprocValue>
		<preprocStack><c path="Array"><a><r><x path="Bool"/></r></a></c></preprocStack>
		<parsePreproCond set="method" line="1554"><f a=""><e path="hscript.Expr"/></f></parsePreproCond>
		<evalPreproCond set="method" line="1569"><f a="e">
	<e path="hscript.Expr"/>
	<x path="Bool"/>
</f></evalPreproCond>
		<preprocess set="method" line="1587"><f a="id">
	<c path="String"/>
	<e path="hscript.Token"/>
</f></preprocess>
		<skipTokens set="method" line="1620"><f a=""><x path="Void"/></f></skipTokens>
		<tokenComment set="method" line="1635"><f a="op:char">
	<c path="String"/>
	<x path="Int"/>
	<x path="Null"><e path="hscript.Token"/></x>
</f></tokenComment>
		<constString set="method" line="1677"><f a="c">
	<e path="hscript.Const"/>
	<c path="String"/>
</f></constString>
		<tokenString set="method" line="1688"><f a="t">
	<e path="hscript.Token"/>
	<c path="String"/>
</f></tokenString>
		<new public="1" set="method" line="110"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hscript.Tools" params="" file="/usr/local/lib/haxe/lib/hscript/2,3,0/hscript/Tools.hx">
		<iter public="1" set="method" line="27" static="1"><f a="e:f">
	<e path="hscript.Expr"/>
	<f a="">
		<e path="hscript.Expr"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></iter>
		<map public="1" set="method" line="63" static="1"><f a="e:f">
	<e path="hscript.Expr"/>
	<f a="">
		<e path="hscript.Expr"/>
		<e path="hscript.Expr"/>
	</f>
	<e path="hscript.Expr"/>
</f></map>
		<expr public="1" get="inline" set="null" line="93" static="1"><f a="e">
	<e path="hscript.Expr"/>
	<t path="hscript.ExprDef"/>
</f></expr>
		<mk public="1" get="inline" set="null" line="101" static="1"><f a="e:p">
	<t path="hscript.ExprDef"/>
	<e path="hscript.Expr"/>
	<t path="hscript.ExprDef"/>
</f></mk>
	</class>
	<class path="neko.NativeString" params="" file="/usr/local/lib/haxe/std/neko/NativeString.hx"><meta><m n=":keep"/></meta></class>
	<abstract path="neko.vm.LoaderHandle" params="" file="/usr/local/lib/haxe/std/neko/vm/Loader.hx" module="neko.vm.Loader">
		<this><x path="neko.vm.LoaderHandle"/></this>
		<haxe_doc>The Neko object that implements the loader.</haxe_doc>
		<meta>
			<m n=":callable"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="neko.vm.ModuleHandle" params="" file="/usr/local/lib/haxe/std/neko/vm/Module.hx" module="neko.vm.Module">
		<this><x path="neko.vm.ModuleHandle"/></this>
		<haxe_doc>The abstract Neko module handle.</haxe_doc>
		<meta>
			<m n=":callable"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="server.ServerTag" params="" file="src/server/ServerTag.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><x path="Null"><c path="String"/></x></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="server._ServerTag.ServerTag_Impl_" params="" file="src/server/ServerTag.hx" private="1" module="server.ServerTag">
	<KA public="1" get="inline" set="null" expr="cast &quot;KA&quot;" line="5" static="1">
		<x path="server.ServerTag"/>
		<meta>
			<m n=":value"><e>cast "KA"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</KA>
	<USE public="1" get="inline" set="null" expr="cast &quot;USE&quot;" line="6" static="1">
		<x path="server.ServerTag"/>
		<meta>
			<m n=":value"><e>cast "USE"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</USE>
	<BABY public="1" get="inline" set="null" expr="cast &quot;BABY&quot;" line="7" static="1">
		<x path="server.ServerTag"/>
		<meta>
			<m n=":value"><e>cast "BABY"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BABY>
	<SELF public="1" get="inline" set="null" expr="cast &quot;SELF&quot;" line="8" static="1">
		<x path="server.ServerTag"/>
		<meta>
			<m n=":value"><e>cast "SELF"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SELF>
	<UBABY public="1" get="inline" set="null" expr="cast &quot;UBABY&quot;" line="9" static="1">
		<x path="server.ServerTag"/>
		<meta>
			<m n=":value"><e>cast "UBABY"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UBABY>
	<REMV public="1" get="inline" set="null" expr="cast &quot;REMV&quot;" line="10" static="1">
		<x path="server.ServerTag"/>
		<meta>
			<m n=":value"><e>cast "REMV"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</REMV>
	<SREMV public="1" get="inline" set="null" expr="cast &quot;SREMV&quot;" line="11" static="1">
		<x path="server.ServerTag"/>
		<meta>
			<m n=":value"><e>cast "SREMV"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SREMV>
	<DROP public="1" get="inline" set="null" expr="cast &quot;DROP&quot;" line="12" static="1">
		<x path="server.ServerTag"/>
		<meta>
			<m n=":value"><e>cast "DROP"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DROP>
	<KILL public="1" get="inline" set="null" expr="cast &quot;KILL&quot;" line="13" static="1">
		<x path="server.ServerTag"/>
		<meta>
			<m n=":value"><e>cast "KILL"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</KILL>
	<JUMP public="1" get="inline" set="null" expr="cast &quot;JUMP&quot;" line="14" static="1">
		<x path="server.ServerTag"/>
		<meta>
			<m n=":value"><e>cast "JUMP"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</JUMP>
	<EMOT public="1" get="inline" set="null" expr="cast &quot;EMOT&quot;" line="15" static="1">
		<x path="server.ServerTag"/>
		<meta>
			<m n=":value"><e>cast "EMOT"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EMOT>
	<DIE public="1" get="inline" set="null" expr="cast &quot;DIE&quot;" line="16" static="1">
		<x path="server.ServerTag"/>
		<meta>
			<m n=":value"><e>cast "DIE"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DIE>
	<GRAVE public="1" get="inline" set="null" expr="cast &quot;GRAVE&quot;" line="17" static="1">
		<x path="server.ServerTag"/>
		<meta>
			<m n=":value"><e>cast "GRAVE"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GRAVE>
	<OWNER public="1" get="inline" set="null" expr="cast &quot;OWNER&quot;" line="18" static="1">
		<x path="server.ServerTag"/>
		<meta>
			<m n=":value"><e>cast "OWNER"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OWNER>
	<FORCE public="1" get="inline" set="null" expr="cast &quot;FORCE&quot;" line="19" static="1">
		<x path="server.ServerTag"/>
		<meta>
			<m n=":value"><e>cast "FORCE"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FORCE>
	<PING public="1" get="inline" set="null" expr="cast &quot;PING&quot;" line="20" static="1">
		<x path="server.ServerTag"/>
		<meta>
			<m n=":value"><e>cast "PING"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PING>
	<VOGS public="1" get="inline" set="null" expr="cast &quot;VOGS&quot;" line="22" static="1">
		<x path="server.ServerTag"/>
		<meta>
			<m n=":value"><e>cast "VOGS"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VOGS>
	<VOGN public="1" get="inline" set="null" expr="cast &quot;VOGN&quot;" line="23" static="1">
		<x path="server.ServerTag"/>
		<meta>
			<m n=":value"><e>cast "VOGN"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VOGN>
	<VOGP public="1" get="inline" set="null" expr="cast &quot;VOGP&quot;" line="24" static="1">
		<x path="server.ServerTag"/>
		<meta>
			<m n=":value"><e>cast "VOGP"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VOGP>
	<VOGM public="1" get="inline" set="null" expr="cast &quot;VOGM&quot;" line="25" static="1">
		<x path="server.ServerTag"/>
		<meta>
			<m n=":value"><e>cast "VOGM"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VOGM>
	<VOGI public="1" get="inline" set="null" expr="cast &quot;VOGI&quot;" line="26" static="1">
		<x path="server.ServerTag"/>
		<meta>
			<m n=":value"><e>cast "VOGI"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VOGI>
	<VOGT public="1" get="inline" set="null" expr="cast &quot;VOGT&quot;" line="27" static="1">
		<x path="server.ServerTag"/>
		<meta>
			<m n=":value"><e>cast "VOGT"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VOGT>
	<VOGX public="1" get="inline" set="null" expr="cast &quot;VOGX&quot;" line="28" static="1">
		<x path="server.ServerTag"/>
		<meta>
			<m n=":value"><e>cast "VOGX"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VOGX>
	<PHOTO public="1" get="inline" set="null" expr="cast &quot;PHOTO&quot;" line="30" static="1">
		<x path="server.ServerTag"/>
		<meta>
			<m n=":value"><e>cast "PHOTO"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PHOTO>
	<SAY public="1" get="inline" set="null" expr="cast &quot;SAY&quot;" line="32" static="1">
		<x path="server.ServerTag"/>
		<meta>
			<m n=":value"><e>cast "SAY"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SAY>
	<fromString set="method" line="33" static="1">
		<f a="value">
			<c path="String"/>
			<x path="server.ServerTag"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="server._ServerTag.ServerTag_Impl_" params="" file="src/server/ServerTag.hx" private="1" module="server.ServerTag">
		<KA public="1" get="inline" set="null" expr="cast &quot;KA&quot;" line="5" static="1">
			<x path="server.ServerTag"/>
			<meta>
				<m n=":value"><e>cast "KA"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</KA>
		<USE public="1" get="inline" set="null" expr="cast &quot;USE&quot;" line="6" static="1">
			<x path="server.ServerTag"/>
			<meta>
				<m n=":value"><e>cast "USE"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</USE>
		<BABY public="1" get="inline" set="null" expr="cast &quot;BABY&quot;" line="7" static="1">
			<x path="server.ServerTag"/>
			<meta>
				<m n=":value"><e>cast "BABY"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BABY>
		<SELF public="1" get="inline" set="null" expr="cast &quot;SELF&quot;" line="8" static="1">
			<x path="server.ServerTag"/>
			<meta>
				<m n=":value"><e>cast "SELF"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SELF>
		<UBABY public="1" get="inline" set="null" expr="cast &quot;UBABY&quot;" line="9" static="1">
			<x path="server.ServerTag"/>
			<meta>
				<m n=":value"><e>cast "UBABY"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UBABY>
		<REMV public="1" get="inline" set="null" expr="cast &quot;REMV&quot;" line="10" static="1">
			<x path="server.ServerTag"/>
			<meta>
				<m n=":value"><e>cast "REMV"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</REMV>
		<SREMV public="1" get="inline" set="null" expr="cast &quot;SREMV&quot;" line="11" static="1">
			<x path="server.ServerTag"/>
			<meta>
				<m n=":value"><e>cast "SREMV"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SREMV>
		<DROP public="1" get="inline" set="null" expr="cast &quot;DROP&quot;" line="12" static="1">
			<x path="server.ServerTag"/>
			<meta>
				<m n=":value"><e>cast "DROP"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DROP>
		<KILL public="1" get="inline" set="null" expr="cast &quot;KILL&quot;" line="13" static="1">
			<x path="server.ServerTag"/>
			<meta>
				<m n=":value"><e>cast "KILL"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</KILL>
		<JUMP public="1" get="inline" set="null" expr="cast &quot;JUMP&quot;" line="14" static="1">
			<x path="server.ServerTag"/>
			<meta>
				<m n=":value"><e>cast "JUMP"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</JUMP>
		<EMOT public="1" get="inline" set="null" expr="cast &quot;EMOT&quot;" line="15" static="1">
			<x path="server.ServerTag"/>
			<meta>
				<m n=":value"><e>cast "EMOT"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EMOT>
		<DIE public="1" get="inline" set="null" expr="cast &quot;DIE&quot;" line="16" static="1">
			<x path="server.ServerTag"/>
			<meta>
				<m n=":value"><e>cast "DIE"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DIE>
		<GRAVE public="1" get="inline" set="null" expr="cast &quot;GRAVE&quot;" line="17" static="1">
			<x path="server.ServerTag"/>
			<meta>
				<m n=":value"><e>cast "GRAVE"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GRAVE>
		<OWNER public="1" get="inline" set="null" expr="cast &quot;OWNER&quot;" line="18" static="1">
			<x path="server.ServerTag"/>
			<meta>
				<m n=":value"><e>cast "OWNER"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OWNER>
		<FORCE public="1" get="inline" set="null" expr="cast &quot;FORCE&quot;" line="19" static="1">
			<x path="server.ServerTag"/>
			<meta>
				<m n=":value"><e>cast "FORCE"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FORCE>
		<PING public="1" get="inline" set="null" expr="cast &quot;PING&quot;" line="20" static="1">
			<x path="server.ServerTag"/>
			<meta>
				<m n=":value"><e>cast "PING"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PING>
		<VOGS public="1" get="inline" set="null" expr="cast &quot;VOGS&quot;" line="22" static="1">
			<x path="server.ServerTag"/>
			<meta>
				<m n=":value"><e>cast "VOGS"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VOGS>
		<VOGN public="1" get="inline" set="null" expr="cast &quot;VOGN&quot;" line="23" static="1">
			<x path="server.ServerTag"/>
			<meta>
				<m n=":value"><e>cast "VOGN"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VOGN>
		<VOGP public="1" get="inline" set="null" expr="cast &quot;VOGP&quot;" line="24" static="1">
			<x path="server.ServerTag"/>
			<meta>
				<m n=":value"><e>cast "VOGP"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VOGP>
		<VOGM public="1" get="inline" set="null" expr="cast &quot;VOGM&quot;" line="25" static="1">
			<x path="server.ServerTag"/>
			<meta>
				<m n=":value"><e>cast "VOGM"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VOGM>
		<VOGI public="1" get="inline" set="null" expr="cast &quot;VOGI&quot;" line="26" static="1">
			<x path="server.ServerTag"/>
			<meta>
				<m n=":value"><e>cast "VOGI"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VOGI>
		<VOGT public="1" get="inline" set="null" expr="cast &quot;VOGT&quot;" line="27" static="1">
			<x path="server.ServerTag"/>
			<meta>
				<m n=":value"><e>cast "VOGT"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VOGT>
		<VOGX public="1" get="inline" set="null" expr="cast &quot;VOGX&quot;" line="28" static="1">
			<x path="server.ServerTag"/>
			<meta>
				<m n=":value"><e>cast "VOGX"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VOGX>
		<PHOTO public="1" get="inline" set="null" expr="cast &quot;PHOTO&quot;" line="30" static="1">
			<x path="server.ServerTag"/>
			<meta>
				<m n=":value"><e>cast "PHOTO"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PHOTO>
		<SAY public="1" get="inline" set="null" expr="cast &quot;SAY&quot;" line="32" static="1">
			<x path="server.ServerTag"/>
			<meta>
				<m n=":value"><e>cast "SAY"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SAY>
		<fromString set="method" line="33" static="1">
			<f a="value">
				<c path="String"/>
				<x path="server.ServerTag"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="settings.Settings" params="" file="src/settings/Settings.hx">
		<data public="1" set="accessor" expr="{ }">
			<t path="settings.Data"/>
			<meta>
				<m n=":value"><e>{ }</e></m>
				<m n=":isVar"/>
			</meta>
		</data>
		<set_data set="method" line="11"><f a="value">
	<t path="settings.Data"/>
	<t path="settings.Data"/>
</f></set_data>
		<fail public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</fail>
		<new public="1" set="method" line="29"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="settings.Data" params="" file="src/settings/Settings.hx" module="settings.Settings"><x path="haxe.DynamicAccess"><d/></x></typedef>
	<typedef path="sys.FileStat" params="" file="/usr/local/lib/haxe/std/sys/FileStat.hx">
		<a>
			<uid>
				<x path="Int"/>
				<haxe_doc>The user id for the file owner.</haxe_doc>
			</uid>
			<size>
				<x path="Int"/>
				<haxe_doc>The size of the file, in bytes.</haxe_doc>
			</size>
			<rdev>
				<x path="Int"/>
				<haxe_doc>The device type on which stat resides (special files only).</haxe_doc>
			</rdev>
			<nlink>
				<x path="Int"/>
				<haxe_doc>The number of hard links to stat.</haxe_doc>
			</nlink>
			<mtime>
				<c path="Date"/>
				<haxe_doc>The last modification time for the file.</haxe_doc>
			</mtime>
			<mode>
				<x path="Int"/>
				<haxe_doc>The permission bits of stat. The meaning of the bits is platform dependent.</haxe_doc>
			</mode>
			<ino>
				<x path="Int"/>
				<haxe_doc>The inode number for stat.</haxe_doc>
			</ino>
			<gid>
				<x path="Int"/>
				<haxe_doc>The user group id for the file owner.</haxe_doc>
			</gid>
			<dev>
				<x path="Int"/>
				<haxe_doc>The device on which stat resides.</haxe_doc>
			</dev>
			<ctime>
				<c path="Date"/>
				<haxe_doc>The creation time for the file (not all file systems support this).</haxe_doc>
			</ctime>
			<atime>
				<c path="Date"/>
				<haxe_doc>The last access time for the file (when enabled by the file system).</haxe_doc>
			</atime>
		</a>
		<haxe_doc>File information, as given by `sys.FileSystem.stat`.</haxe_doc>
	</typedef>
	<enum path="sys._FileSystem.FileKind" params="" file="/usr/local/lib/haxe/std/neko/_std/sys/FileSystem.hx" private="1" module="sys.FileSystem">
		<kdir/>
		<kfile/>
		<kother a="k"><c path="String"/></kother>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="sys.Http" params="" file="/usr/local/lib/haxe/std/sys/Http.hx">
		<extends path="haxe.http.HttpBase"/>
		<PROXY public="1" expr="null" line="46" static="1">
			<a>
				<port><x path="Int"/></port>
				<host><c path="String"/></host>
				<auth><a>
	<user><c path="String"/></user>
	<pass><c path="String"/></pass>
</a></auth>
			</a>
			<meta><m n=":value"><e>null</e></m></meta>
		</PROXY>
		<noShutdown public="1"><x path="Bool"/></noShutdown>
		<cnxTimeout public="1"><x path="Float"/></cnxTimeout>
		<responseHeaders public="1"><t path="Map">
	<c path="String"/>
	<c path="String"/>
</t></responseHeaders>
		<chunk_size><x path="Null"><x path="Int"/></x></chunk_size>
		<chunk_buf><c path="haxe.io.Bytes"/></chunk_buf>
		<file><a>
	<size><x path="Int"/></size>
	<param><c path="String"/></param>
	<mimeType><c path="String"/></mimeType>
	<io><c path="haxe.io.Input"/></io>
	<filename><c path="String"/></filename>
</a></file>
		<request public="1" set="method" line="56"><f a="?post">
	<x path="Bool"/>
	<x path="Void"/>
</f></request>
		<customRequest public="1" set="method" line="90"><f a="post:api:?sock:?method">
	<x path="Bool"/>
	<c path="haxe.io.Output"/>
	<c path="sys.net.Socket"/>
	<c path="String"/>
	<x path="Void"/>
</f></customRequest>
		<writeBody set="method" line="253"><f a="body:fileInput:fileSize:boundary:sock">
	<x path="Null"><c path="haxe.io.BytesOutput"/></x>
	<x path="Null"><c path="haxe.io.Input"/></x>
	<x path="Int"/>
	<x path="Null"><c path="String"/></x>
	<c path="sys.net.Socket"/>
	<x path="Void"/>
</f></writeBody>
		<readHttpResponse set="method" line="278"><f a="api:sock">
	<c path="haxe.io.Output"/>
	<c path="sys.net.Socket"/>
	<x path="Void"/>
</f></readHttpResponse>
		<readChunk set="method" line="420"><f a="chunk_re:api:buf:len">
	<c path="EReg"/>
	<c path="haxe.io.Output"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></readChunk>
		<new public="1" set="method" line="48"><f a="url">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="sys.io.FileHandle" params="" file="/usr/local/lib/haxe/std/neko/_std/sys/io/File.hx" module="sys.io.File"><meta><m n=":flatEnum"/></meta></enum>
	<class path="sys.io.File" params="" file="/usr/local/lib/haxe/std/neko/_std/sys/io/File.hx">
		<getContent public="1" set="method" line="28" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Retrieves the content of the file specified by `path` as a String.

		If the file does not exist or can not be read, an exception is thrown.

		`sys.FileSystem.exists` can be used to check for existence.

		If `path` is null, the result is unspecified.</haxe_doc>
		</getContent>
		<saveContent public="1" set="method" line="36" static="1">
			<f a="path:content">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores `content` in the file specified by `path`.

		If the file cannot be written to, an exception is thrown.

		If `path` or `content` are null, the result is unspecified.</haxe_doc>
		</saveContent>
		<write public="1" set="method" line="52" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileOutput"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ binary : true }</e></m>
			</meta>
			<haxe_doc>Returns an `FileOutput` handle to the file specified by `path`.

		If `binary` is true, the file is opened in binary mode. Otherwise it is
		opened in non-binary mode.

		If the file cannot be written to, an exception is thrown.

		Operations on the returned `FileOutput` handle write to the opened file.
		If the file existed, its previous content is overwritten.

		File handles should be closed via `FileOutput.close` once the operation
		is complete.

		If `path` is null, the result is unspecified.</haxe_doc>
		</write>
		<file_contents expr="neko.Lib.load(&quot;std&quot;, &quot;file_contents&quot;, 1)" line="75" static="1">
			<f a="">
				<unknown/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "file_contents", 1)</e></m></meta>
		</file_contents>
		<file_open expr="neko.Lib.load(&quot;std&quot;, &quot;file_open&quot;, 2)" line="76" static="1">
			<f a=":">
				<unknown/>
				<unknown/>
				<e path="sys.io.FileHandle"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "file_open", 2)</e></m></meta>
		</file_open>
		<haxe_doc>API for reading and writing files.

	See `sys.FileSystem` for the complementary file system API.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.io.FileInput" params="" file="/usr/local/lib/haxe/std/neko/_std/sys/io/FileInput.hx">
		<extends path="haxe.io.Input"/>
		<file_read expr="neko.Lib.load(&quot;std&quot;, &quot;file_read&quot;, 4)" line="77" static="1">
			<f a=":::">
				<e path="sys.io.FileHandle"/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "file_read", 4)</e></m></meta>
		</file_read>
		<file_read_char expr="neko.Lib.load(&quot;std&quot;, &quot;file_read_char&quot;, 1)" line="78" static="1">
			<f a="">
				<e path="sys.io.FileHandle"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "file_read_char", 1)</e></m></meta>
		</file_read_char>
		<file_close expr="neko.Lib.load(&quot;std&quot;, &quot;file_close&quot;, 1)" line="80" static="1">
			<f a="">
				<e path="sys.io.FileHandle"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "file_close", 1)</e></m></meta>
		</file_close>
		<__f><e path="sys.io.FileHandle"/></__f>
		<readByte public="1" set="method" line="32" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
		</readByte>
		<readBytes public="1" set="method" line="43" override="1">
			<f a="s:p:l">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</readBytes>
		<close public="1" set="method" line="54" override="1"><f a=""><x path="Void"/></f></close>
		<new set="method" line="28"><f a="f">
	<e path="sys.io.FileHandle"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Use `sys.io.File.read` to create a `FileInput`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.io.FileOutput" params="" file="/usr/local/lib/haxe/std/neko/_std/sys/io/FileOutput.hx">
		<extends path="haxe.io.Output"/>
		<file_close expr="neko.Lib.load(&quot;std&quot;, &quot;file_close&quot;, 1)" line="64" static="1">
			<f a="">
				<e path="sys.io.FileHandle"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "file_close", 1)</e></m></meta>
		</file_close>
		<file_flush expr="neko.Lib.load(&quot;std&quot;, &quot;file_flush&quot;, 1)" line="68" static="1">
			<f a="">
				<e path="sys.io.FileHandle"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "file_flush", 1)</e></m></meta>
		</file_flush>
		<file_write expr="neko.Lib.load(&quot;std&quot;, &quot;file_write&quot;, 4)" line="69" static="1">
			<f a=":::">
				<e path="sys.io.FileHandle"/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "file_write", 4)</e></m></meta>
		</file_write>
		<file_write_char expr="neko.Lib.load(&quot;std&quot;, &quot;file_write_char&quot;, 2)" line="70" static="1">
			<f a=":">
				<e path="sys.io.FileHandle"/>
				<x path="Int"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "file_write_char", 2)</e></m></meta>
		</file_write_char>
		<__f><e path="sys.io.FileHandle"/></__f>
		<writeByte public="1" set="method" line="32" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="39" override="1"><f a="s:p:l">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<flush public="1" set="method" line="43" override="1"><f a=""><x path="Void"/></f></flush>
		<close public="1" set="method" line="47" override="1"><f a=""><x path="Void"/></f></close>
		<new set="method" line="28"><f a="f">
	<e path="sys.io.FileHandle"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Use `sys.io.File.write` to create a `FileOutput`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.net.Host" params="" file="/usr/local/lib/haxe/std/neko/_std/sys/net/Host.hx">
		<host_resolve expr="neko.Lib.load(&quot;std&quot;, &quot;host_resolve&quot;, 1)" line="53" static="1">
			<f a="">
				<unknown/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "host_resolve", 1)</e></m></meta>
		</host_resolve>
		<host_to_string expr="neko.Lib.load(&quot;std&quot;, &quot;host_to_string&quot;, 1)" line="55" static="1">
			<f a="">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "host_to_string", 1)</e></m></meta>
		</host_to_string>
		<host public="1" set="null">
			<c path="String"/>
			<haxe_doc>The provided host string.</haxe_doc>
		</host>
		<ip public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The actual IP corresponding to the host.</haxe_doc>
		</ip>
		<toString public="1" set="method" line="37">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the IP representation of the host</haxe_doc>
		</toString>
		<new public="1" set="method" line="32">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a new Host : the name can be an IP in the form "127.0.0.1" or an host name such as "google.com", in which case
		the corresponding IP address is resolved using DNS. An exception occur if the host name could not be found.</haxe_doc>
		</new>
		<haxe_doc>A given IP host name.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
			<m n=":keepInit"/>
		</meta>
	</class>
	<abstract path="sys.net.SocketHandle" params="" file="/usr/local/lib/haxe/std/neko/_std/sys/net/Socket.hx" module="sys.net.Socket">
		<this><x path="sys.net.SocketHandle"/></this>
		<meta>
			<m n=":callable"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<class path="sys.net._Socket.SocketOutput" params="" file="/usr/local/lib/haxe/std/neko/_std/sys/net/Socket.hx" private="1" module="sys.net.Socket">
		<extends path="haxe.io.Output"/>
		<socket_close expr="neko.Lib.load(&quot;std&quot;, &quot;socket_close&quot;, 1)" line="68" static="1">
			<f a="">
				<x path="sys.net.SocketHandle"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "socket_close", 1)</e></m></meta>
		</socket_close>
		<socket_send_char expr="neko.Lib.load(&quot;std&quot;, &quot;socket_send_char&quot;, 2)" line="69" static="1">
			<f a=":">
				<x path="sys.net.SocketHandle"/>
				<x path="Int"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "socket_send_char", 2)</e></m></meta>
		</socket_send_char>
		<socket_send expr="neko.Lib.load(&quot;std&quot;, &quot;socket_send&quot;, 4)" line="70" static="1">
			<f a=":::">
				<x path="sys.net.SocketHandle"/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "socket_send", 4)</e></m></meta>
		</socket_send>
		<__s><x path="sys.net.SocketHandle"/></__s>
		<writeByte public="1" set="method" line="38" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="51" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<close public="1" set="method" line="62" override="1"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="34"><f a="s">
	<x path="sys.net.SocketHandle"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="sys.net._Socket.SocketInput" params="" file="/usr/local/lib/haxe/std/neko/_std/sys/net/Socket.hx" private="1" module="sys.net.Socket">
		<extends path="haxe.io.Input"/>
		<socket_recv expr="neko.Lib.load(&quot;std&quot;, &quot;socket_recv&quot;, 4)" line="114" static="1">
			<f a=":::">
				<x path="sys.net.SocketHandle"/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "socket_recv", 4)</e></m></meta>
		</socket_recv>
		<socket_recv_char expr="neko.Lib.load(&quot;std&quot;, &quot;socket_recv_char&quot;, 1)" line="115" static="1">
			<f a="">
				<x path="sys.net.SocketHandle"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "socket_recv_char", 1)</e></m></meta>
		</socket_recv_char>
		<socket_close expr="neko.Lib.load(&quot;std&quot;, &quot;socket_close&quot;, 1)" line="116" static="1">
			<f a="">
				<x path="sys.net.SocketHandle"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "socket_close", 1)</e></m></meta>
		</socket_close>
		<__s><x path="sys.net.SocketHandle"/></__s>
		<readByte public="1" set="method" line="80" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="93" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="108" override="1"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="76"><f a="s">
	<x path="sys.net.SocketHandle"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="sys.net.Socket" params="" file="/usr/local/lib/haxe/std/neko/_std/sys/net/Socket.hx">
		<socket_new expr="neko.Lib.load(&quot;std&quot;, &quot;socket_new&quot;, 1)" line="269" static="1">
			<f a="">
				<x path="Bool"/>
				<x path="sys.net.SocketHandle"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "socket_new", 1)</e></m></meta>
		</socket_new>
		<socket_close expr="neko.Lib.load(&quot;std&quot;, &quot;socket_close&quot;, 1)" line="270" static="1">
			<f a="">
				<x path="sys.net.SocketHandle"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "socket_close", 1)</e></m></meta>
		</socket_close>
		<socket_connect expr="neko.Lib.load(&quot;std&quot;, &quot;socket_connect&quot;, 3)" line="273" static="1">
			<f a="::">
				<x path="sys.net.SocketHandle"/>
				<x path="Int"/>
				<x path="Int"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "socket_connect", 3)</e></m></meta>
		</socket_connect>
		<socket_listen expr="neko.Lib.load(&quot;std&quot;, &quot;socket_listen&quot;, 2)" line="274" static="1">
			<f a=":">
				<x path="sys.net.SocketHandle"/>
				<x path="Int"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "socket_listen", 2)</e></m></meta>
		</socket_listen>
		<socket_bind expr="neko.Lib.load(&quot;std&quot;, &quot;socket_bind&quot;, 3)" line="276" static="1">
			<f a="::">
				<x path="sys.net.SocketHandle"/>
				<x path="Int"/>
				<x path="Int"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "socket_bind", 3)</e></m></meta>
		</socket_bind>
		<socket_accept expr="neko.Lib.load(&quot;std&quot;, &quot;socket_accept&quot;, 1)" line="277" static="1">
			<f a="">
				<x path="sys.net.SocketHandle"/>
				<x path="sys.net.SocketHandle"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "socket_accept", 1)</e></m></meta>
		</socket_accept>
		<socket_set_timeout expr="neko.Lib.load(&quot;std&quot;, &quot;socket_set_timeout&quot;, 2)" line="280" static="1">
			<f a=":">
				<x path="sys.net.SocketHandle"/>
				<x path="Float"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "socket_set_timeout", 2)</e></m></meta>
		</socket_set_timeout>
		<socket_shutdown expr="neko.Lib.load(&quot;std&quot;, &quot;socket_shutdown&quot;, 3)" line="281" static="1">
			<f a="::">
				<x path="sys.net.SocketHandle"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "socket_shutdown", 3)</e></m></meta>
		</socket_shutdown>
		<socket_set_blocking expr="neko.Lib.load(&quot;std&quot;, &quot;socket_set_blocking&quot;, 2)" line="282" static="1">
			<f a=":">
				<x path="sys.net.SocketHandle"/>
				<x path="Bool"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "socket_set_blocking", 2)</e></m></meta>
		</socket_set_blocking>
		<socket_set_fast_send expr="neko.Lib.loadLazy(&quot;std&quot;, &quot;socket_set_fast_send&quot;, 2)" line="283" static="1">
			<f a=":">
				<x path="sys.net.SocketHandle"/>
				<x path="Bool"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("std", "socket_set_fast_send", 2)</e></m></meta>
		</socket_set_fast_send>
		<__s><x path="sys.net.SocketHandle"/></__s>
		<input public="1" set="null">
			<c path="haxe.io.Input"/>
			<haxe_doc>The stream on which you can read available data. By default the stream is blocking until the requested data is available,
		use `setBlocking(false)` or `setTimeout` to prevent infinite waiting.</haxe_doc>
		</input>
		<output public="1" set="null">
			<c path="haxe.io.Output"/>
			<haxe_doc>The stream on which you can send data. Please note that in case the output buffer you will block while writing the data, use `setBlocking(false)` or `setTimeout` to prevent that.</haxe_doc>
		</output>
		<init set="method" line="131"><f a=""><x path="Void"/></f></init>
		<close public="1" set="method" line="138">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Closes the socket : make sure to properly close all your sockets or you will crash when you run out of file descriptors.</haxe_doc>
		</close>
		<connect public="1" set="method" line="156">
			<f a="host:port">
				<c path="sys.net.Host"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Connect to the given server host/port. Throw an exception in case we couldn't successfully connect.</haxe_doc>
		</connect>
		<listen public="1" set="method" line="170">
			<f a="connections">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allow the socket to listen for incoming questions. The parameter tells how many pending connections we can have until they get refused. Use `accept()` to accept incoming connections.</haxe_doc>
		</listen>
		<shutdown public="1" set="method" line="174">
			<f a="read:write">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Shutdown the socket, either for reading or writing.</haxe_doc>
		</shutdown>
		<bind public="1" set="method" line="178">
			<f a="host:port">
				<c path="sys.net.Host"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Bind the socket to the given host/port so it can afterwards listen for connections there.</haxe_doc>
		</bind>
		<accept public="1" set="method" line="182">
			<f a=""><c path="sys.net.Socket"/></f>
			<haxe_doc>Accept a new connected client. This will return a connected socket on which you can read/write some data.</haxe_doc>
		</accept>
		<setTimeout public="1" set="method" line="211">
			<f a="timeout">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Gives a timeout (in seconds) after which blocking socket operations (such as reading and writing) will abort and throw an exception.</haxe_doc>
		</setTimeout>
		<setBlocking public="1" set="method" line="219">
			<f a="b">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Change the blocking mode of the socket. A blocking socket is the default behavior. A non-blocking socket will abort blocking operations immediately by throwing a haxe.io.Error.Blocked value.</haxe_doc>
		</setBlocking>
		<setFastSend public="1" set="method" line="223">
			<f a="b">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allows the socket to immediately send the data when written to its output : this will cause less ping but might increase the number of packets / data size, especially when doing a lot of small writes.</haxe_doc>
		</setFastSend>
		<new public="1" set="method" line="127">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new unconnected socket.</haxe_doc>
		</new>
		<haxe_doc>A TCP socket class : allow you to both connect to a given server and exchange messages or start your own server and wait for connections.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.ssl.Certificate" params="" file="/usr/local/lib/haxe/std/neko/_std/sys/ssl/Certificate.hx">
		<loadFile public="1" set="method" line="36" static="1">
			<f a="file">
				<c path="String"/>
				<c path="sys.ssl.Certificate"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</loadFile>
		<loadPath public="1" set="method" line="40" static="1">
			<f a="path">
				<c path="String"/>
				<c path="sys.ssl.Certificate"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</loadPath>
		<loadDefaults public="1" set="method" line="48" static="1"><f a=""><c path="sys.ssl.Certificate"/></f></loadDefaults>
		<cert_load_defaults expr="neko.Lib.loadLazy(&quot;ssl&quot;, &quot;cert_load_defaults&quot;, 0)" line="139" static="1">
			<f a=""><unknown/></f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("ssl", "cert_load_defaults", 0)</e></m></meta>
		</cert_load_defaults>
		<cert_load_file expr="neko.Lib.loadLazy(&quot;ssl&quot;, &quot;cert_load_file&quot;, 1)" line="140" static="1">
			<f a="">
				<unknown/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("ssl", "cert_load_file", 1)</e></m></meta>
		</cert_load_file>
		<cert_load_path expr="neko.Lib.loadLazy(&quot;ssl&quot;, &quot;cert_load_path&quot;, 1)" line="141" static="1">
			<f a="">
				<unknown/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("ssl", "cert_load_path", 1)</e></m></meta>
		</cert_load_path>
		<__h><x path="Null"><c path="sys.ssl.Certificate"/></x></__h>
		<__x><d/></__x>
		<new set="method" line="31">
			<f a="x:?h">
				<d/>
				<c path="sys.ssl.Certificate"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>sys.ssl.Socket</e></m></meta>
		</new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<typedef path="sys.ssl._Key.PKEY" params="" file="/usr/local/lib/haxe/std/neko/_std/sys/ssl/Key.hx" private="1" module="sys.ssl.Key"><d/></typedef>
	<class path="sys.ssl.Key" params="" file="/usr/local/lib/haxe/std/neko/_std/sys/ssl/Key.hx">
		<__k><t path="sys.ssl._Key.PKEY"/></__k>
		<new set="method" line="31"><f a="k">
	<t path="sys.ssl._Key.PKEY"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<typedef path="sys.ssl._Socket.SocketHandle" params="" file="/usr/local/lib/haxe/std/neko/_std/sys/ssl/Socket.hx" private="1" module="sys.ssl.Socket"><d/></typedef>
	<typedef path="sys.ssl._Socket.CTX" params="" file="/usr/local/lib/haxe/std/neko/_std/sys/ssl/Socket.hx" private="1" module="sys.ssl.Socket"><d/></typedef>
	<typedef path="sys.ssl._Socket.SSL" params="" file="/usr/local/lib/haxe/std/neko/_std/sys/ssl/Socket.hx" private="1" module="sys.ssl.Socket"><d/></typedef>
	<class path="sys.ssl._Socket.SocketInput" params="" file="/usr/local/lib/haxe/std/neko/_std/sys/ssl/Socket.hx" private="1" module="sys.ssl.Socket">
		<extends path="haxe.io.Input"/>
		<ssl_recv expr="neko.Lib.loadLazy(&quot;ssl&quot;, &quot;ssl_recv&quot;, 4)" line="74" static="1">
			<f a=":::">
				<t path="sys.ssl._Socket.SSL"/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("ssl", "ssl_recv", 4)</e></m></meta>
		</ssl_recv>
		<ssl_recv_char expr="neko.Lib.loadLazy(&quot;ssl&quot;, &quot;ssl_recv_char&quot;, 1)" line="75" static="1">
			<f a="">
				<t path="sys.ssl._Socket.SSL"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("ssl", "ssl_recv_char", 1)</e></m></meta>
		</ssl_recv_char>
		<__s>
			<c path="sys.ssl.Socket"/>
			<meta><m n=":allow"><e>sys.ssl.Socket</e></m></meta>
		</__s>
		<readByte public="1" set="method" line="36" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="50" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="68" override="1"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="32"><f a="s">
	<c path="sys.ssl.Socket"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="sys.ssl._Socket.SocketOutput" params="" file="/usr/local/lib/haxe/std/neko/_std/sys/ssl/Socket.hx" private="1" module="sys.ssl.Socket">
		<extends path="haxe.io.Output"/>
		<ssl_send_char expr="neko.Lib.loadLazy(&quot;ssl&quot;, &quot;ssl_send_char&quot;, 2)" line="117" static="1">
			<f a=":">
				<t path="sys.ssl._Socket.SSL"/>
				<x path="Int"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("ssl", "ssl_send_char", 2)</e></m></meta>
		</ssl_send_char>
		<ssl_send expr="neko.Lib.loadLazy(&quot;ssl&quot;, &quot;ssl_send&quot;, 4)" line="118" static="1">
			<f a=":::">
				<t path="sys.ssl._Socket.SSL"/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("ssl", "ssl_send", 4)</e></m></meta>
		</ssl_send>
		<__s>
			<c path="sys.ssl.Socket"/>
			<meta><m n=":allow"><e>sys.ssl.Socket</e></m></meta>
		</__s>
		<writeByte public="1" set="method" line="85" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="99" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<close public="1" set="method" line="111" override="1"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="81"><f a="s">
	<c path="sys.ssl.Socket"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="sys.ssl.Socket" params="" file="/usr/local/lib/haxe/std/neko/_std/sys/ssl/Socket.hx">
		<extends path="sys.net.Socket"/>
		<DEFAULT_VERIFY_CERT public="1" expr="true" line="123" static="1">
			<x path="Null"><x path="Bool"/></x>
			<meta><m n=":value"><e>true</e></m></meta>
		</DEFAULT_VERIFY_CERT>
		<DEFAULT_CA public="1" static="1"><x path="Null"><c path="sys.ssl.Certificate"/></x></DEFAULT_CA>
		<ssl_new expr="neko.Lib.loadLazy(&quot;ssl&quot;, &quot;ssl_new&quot;, 1)" line="294" static="1">
			<f a="">
				<t path="sys.ssl._Socket.CTX"/>
				<t path="sys.ssl._Socket.SSL"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("ssl", "ssl_new", 1)</e></m></meta>
		</ssl_new>
		<ssl_close expr="neko.Lib.loadLazy(&quot;ssl&quot;, &quot;ssl_close&quot;, 1)" line="295" static="1">
			<f a="">
				<t path="sys.ssl._Socket.SSL"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("ssl", "ssl_close", 1)</e></m></meta>
		</ssl_close>
		<ssl_handshake expr="neko.Lib.loadLazy(&quot;ssl&quot;, &quot;ssl_handshake&quot;, 1)" line="296" static="1">
			<f a="">
				<t path="sys.ssl._Socket.SSL"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("ssl", "ssl_handshake", 1)</e></m></meta>
		</ssl_handshake>
		<ssl_set_socket expr="neko.Lib.loadLazy(&quot;ssl&quot;, &quot;ssl_set_socket&quot;, 2)" line="297" static="1">
			<f a=":">
				<t path="sys.ssl._Socket.SSL"/>
				<x path="sys.net.SocketHandle"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("ssl", "ssl_set_socket", 2)</e></m></meta>
		</ssl_set_socket>
		<ssl_set_hostname expr="neko.Lib.loadLazy(&quot;ssl&quot;, &quot;ssl_set_hostname&quot;, 2)" line="298" static="1">
			<f a=":">
				<t path="sys.ssl._Socket.SSL"/>
				<unknown/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("ssl", "ssl_set_hostname", 2)</e></m></meta>
		</ssl_set_hostname>
		<conf_new expr="neko.Lib.loadLazy(&quot;ssl&quot;, &quot;conf_new&quot;, 1)" line="304" static="1">
			<f a="">
				<x path="Bool"/>
				<t path="sys.ssl._Socket.CTX"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("ssl", "conf_new", 1)</e></m></meta>
		</conf_new>
		<conf_close expr="neko.Lib.loadLazy(&quot;ssl&quot;, &quot;conf_close&quot;, 1)" line="305" static="1">
			<f a="">
				<t path="sys.ssl._Socket.CTX"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("ssl", "conf_close", 1)</e></m></meta>
		</conf_close>
		<conf_set_ca expr="neko.Lib.loadLazy(&quot;ssl&quot;, &quot;conf_set_ca&quot;, 2)" line="306" static="1">
			<f a=":">
				<t path="sys.ssl._Socket.CTX"/>
				<x path="Null"><unknown/></x>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("ssl", "conf_set_ca", 2)</e></m></meta>
		</conf_set_ca>
		<conf_set_verify expr="neko.Lib.loadLazy(&quot;ssl&quot;, &quot;conf_set_verify&quot;, 2)" line="307" static="1">
			<f a=":">
				<t path="sys.ssl._Socket.CTX"/>
				<x path="Null"><x path="Bool"/></x>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("ssl", "conf_set_verify", 2)</e></m></meta>
		</conf_set_verify>
		<conf_set_cert expr="neko.Lib.loadLazy(&quot;ssl&quot;, &quot;conf_set_cert&quot;, 3)" line="308" static="1">
			<f a="::">
				<t path="sys.ssl._Socket.CTX"/>
				<d/>
				<t path="sys.ssl._Key.PKEY"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("ssl", "conf_set_cert", 3)</e></m></meta>
		</conf_set_cert>
		<conf_set_servername_callback expr="neko.Lib.loadLazy(&quot;ssl&quot;, &quot;conf_set_servername_callback&quot;, 2)" line="309" static="1">
			<f a=":">
				<t path="sys.ssl._Socket.CTX"/>
				<d/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("ssl", "conf_set_servername_callback", 2)</e></m></meta>
		</conf_set_servername_callback>
		<socket_new expr="neko.Lib.load(&quot;std&quot;, &quot;socket_new&quot;, 1)" line="311" static="1">
			<f a="">
				<x path="Bool"/>
				<x path="sys.net.SocketHandle"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "socket_new", 1)</e></m></meta>
		</socket_new>
		<socket_close expr="neko.Lib.load(&quot;std&quot;, &quot;socket_close&quot;, 1)" line="312" static="1">
			<f a="">
				<x path="sys.net.SocketHandle"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "socket_close", 1)</e></m></meta>
		</socket_close>
		<socket_connect expr="neko.Lib.load(&quot;std&quot;, &quot;socket_connect&quot;, 3)" line="313" static="1">
			<f a="::">
				<x path="sys.net.SocketHandle"/>
				<x path="Int"/>
				<x path="Int"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "socket_connect", 3)</e></m></meta>
		</socket_connect>
		<socket_bind expr="neko.Lib.load(&quot;std&quot;, &quot;socket_bind&quot;, 3)" line="314" static="1">
			<f a="::">
				<x path="sys.net.SocketHandle"/>
				<x path="Int"/>
				<x path="Int"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "socket_bind", 3)</e></m></meta>
		</socket_bind>
		<socket_accept expr="neko.Lib.load(&quot;std&quot;, &quot;socket_accept&quot;, 1)" line="315" static="1">
			<f a="">
				<x path="sys.net.SocketHandle"/>
				<x path="sys.net.SocketHandle"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "socket_accept", 1)</e></m></meta>
		</socket_accept>
		<ctx><t path="sys.ssl._Socket.CTX"/></ctx>
		<ssl><t path="sys.ssl._Socket.SSL"/></ssl>
		<verifyCert public="1">
			<x path="Null"><x path="Bool"/></x>
			<haxe_doc>Define if peer certificate is verified during SSL handshake.</haxe_doc>
		</verifyCert>
		<caCert><x path="Null"><c path="sys.ssl.Certificate"/></x></caCert>
		<hostname><c path="String"/></hostname>
		<ownCert><x path="Null"><c path="sys.ssl.Certificate"/></x></ownCert>
		<ownKey><x path="Null"><c path="sys.ssl.Key"/></x></ownKey>
		<altSNIContexts><x path="Null"><c path="Array"><a>
	<match><f a="">
	<c path="String"/>
	<x path="Bool"/>
</f></match>
	<key><c path="sys.ssl.Key"/></key>
	<cert><c path="sys.ssl.Certificate"/></cert>
</a></c></x></altSNIContexts>
		<sniCallback><d/></sniCallback>
		<handshakeDone><x path="Bool"/></handshakeDone>
		<init set="method" line="141" override="1"><f a=""><x path="Void"/></f></init>
		<connect public="1" set="method" line="154" override="1">
			<f a="host:port">
				<c path="sys.net.Host"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</connect>
		<handshake public="1" set="method" line="176">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Perform the SSL handshake.</haxe_doc>
		</handshake>
		<close public="1" set="method" line="216" override="1"><f a=""><x path="Void"/></f></close>
		<bind public="1" set="method" line="237" override="1"><f a="host:port">
	<c path="sys.net.Host"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bind>
		<accept public="1" set="method" line="243" override="1"><f a=""><c path="sys.ssl.Socket"/></f></accept>
		<buildSSLContext set="method" line="263"><f a="server">
	<x path="Bool"/>
	<t path="sys.ssl._Socket.CTX"/>
</f></buildSSLContext>
		<new public="1" set="method" line="122"><f a=""><x path="Void"/></f></new>
		<haxe_doc>A TLS socket class : allow you to both connect to a given server and exchange messages or start your own server and wait for connections.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="sys.thread._Thread.ThreadHandle" params="" file="/usr/local/lib/haxe/std/neko/_std/sys/thread/Thread.hx" private="1" module="sys.thread.Thread">
		<this><x path="sys.thread._Thread.ThreadHandle"/></this>
		<meta>
			<m n=":callable"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="sys.thread.Thread" params="" file="/usr/local/lib/haxe/std/neko/_std/sys/thread/Thread.hx">
		<this><x path="sys.thread._Thread.ThreadHandle"/></this>
		<impl><class path="sys.thread._Thread.Thread_Impl_" params="" file="/usr/local/lib/haxe/std/neko/_std/sys/thread/Thread.hx" private="1" module="sys.thread.Thread">
	<thread_create expr="neko.Lib.load(&quot;std&quot;, &quot;thread_create&quot;, 2)" line="119" static="1">
		<f a=":">
			<f a="_">
				<unknown/>
				<x path="Void"/>
			</f>
			<unknown/>
			<x path="sys.thread._Thread.ThreadHandle"/>
		</f>
		<meta><m n=":value"><e>neko.Lib.load("std", "thread_create", 2)</e></m></meta>
		<haxe_doc><![CDATA[Starts an OS message loop after [osInitialize] has been done.
			In that state, the UI handled by this thread will be updated and
			[sync] calls can be performed. The loop returns when [exitLoop] is
			called for this thread.
		**
		public static function osLoop() {
			if( os_loop == null ) throw "Please call osInitialize() first";
			os_loop();
		}

		/**
			The function [f] will be called by this thread if it's in [osLoop].
			[sync] returns immediately. See [osInitialize] remarks.
		**
		public function sync( f : Void -> Void ) {
			os_sync(handle,f);
		}

		/**
			The function [f] will be called by this thread and the calling thread
			will wait until the result is available then return its value.
		**
		public function syncResult<T>( f : Void -> T ) : T {
			if( this == current() )
				return f();
			var v = new neko.vm.Lock();
			var r = null;
			sync(function() {
				r = f();
				v.release();
			});
			v.wait();
			return r;
		}

		/**
			Exit from [osLoop].
		**
		public function exitLoop() {
			os_loop_stop(handle);
		}

		/**
			If you want to use the [osLoop], [sync] and [syncResult] methods, you
			need to call [osInitialize] before creating any thread or calling [current].
			This will load [os.ndll] library and initialize UI methods for each thread.
		**
		public static function osInitialize() {
			os_loop = neko.Lib.load("os","os_loop",0);
			os_loop_stop = neko.Lib.load("os","os_loop_stop",1);
			os_sync = neko.Lib.load("os","os_sync",2);
		}

		static var os_loop = null;
		static var os_loop_stop = null;
		static var os_sync = null;]]></haxe_doc>
	</thread_create>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="sys.thread._Thread.Thread_Impl_" params="" file="/usr/local/lib/haxe/std/neko/_std/sys/thread/Thread.hx" private="1" module="sys.thread.Thread">
		<thread_create expr="neko.Lib.load(&quot;std&quot;, &quot;thread_create&quot;, 2)" line="119" static="1">
			<f a=":">
				<f a="_">
					<unknown/>
					<x path="Void"/>
				</f>
				<unknown/>
				<x path="sys.thread._Thread.ThreadHandle"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "thread_create", 2)</e></m></meta>
			<haxe_doc><![CDATA[Starts an OS message loop after [osInitialize] has been done.
			In that state, the UI handled by this thread will be updated and
			[sync] calls can be performed. The loop returns when [exitLoop] is
			called for this thread.
		**
		public static function osLoop() {
			if( os_loop == null ) throw "Please call osInitialize() first";
			os_loop();
		}

		/**
			The function [f] will be called by this thread if it's in [osLoop].
			[sync] returns immediately. See [osInitialize] remarks.
		**
		public function sync( f : Void -> Void ) {
			os_sync(handle,f);
		}

		/**
			The function [f] will be called by this thread and the calling thread
			will wait until the result is available then return its value.
		**
		public function syncResult<T>( f : Void -> T ) : T {
			if( this == current() )
				return f();
			var v = new neko.vm.Lock();
			var r = null;
			sync(function() {
				r = f();
				v.release();
			});
			v.wait();
			return r;
		}

		/**
			Exit from [osLoop].
		**
		public function exitLoop() {
			os_loop_stop(handle);
		}

		/**
			If you want to use the [osLoop], [sync] and [syncResult] methods, you
			need to call [osInitialize] before creating any thread or calling [current].
			This will load [os.ndll] library and initialize UI methods for each thread.
		**
		public static function osInitialize() {
			os_loop = neko.Lib.load("os","os_loop",0);
			os_loop_stop = neko.Lib.load("os","os_loop_stop",1);
			os_sync = neko.Lib.load("os","os_sync",2);
		}

		static var os_loop = null;
		static var os_loop_stop = null;
		static var os_sync = null;]]></haxe_doc>
		</thread_create>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
</haxe>